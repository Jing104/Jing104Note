import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as o,o as d}from"./app-BIXQzZxO.js";const l={};function c(a,t){return d(),i("div",null,t[0]||(t[0]=[o('<h1 id="git" tabindex="-1"><a class="header-anchor" href="#git"><span>Git</span></a></h1><p><strong>可以去B站看看GeekHour的干货教程，讲得很不错</strong></p><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h2><h3 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h3><ul><li><p><code>git init</code>：将该目录初始化为仓库（会生成隐藏的git文件，随便更改会破坏所以隐藏，可以通过ls -a查看），可以在后面再加上子目录名，这样就会把子目录创建并设置为仓库</p></li><li><p><code>git clone &lt;ssh/https&gt;</code>：克隆仓库</p></li><li><p><code>cd ..</code>加 <code>rm -rf .git</code>（删除git文件，让仓库变回普通目录）</p></li><li><p><code>git status</code>：查看当前仓库状态。位于哪个分支？有哪些文件以及文件状态。</p></li><li><p><code>git add</code>：将代码从工作区放入暂存区(每次更改完代码都可以先add（类似于给货车装箱，等一批货物装完了再提交到仓库），而不是直接提交到本地仓库)<br><strong>也可以使用通配符，比如：<code>git add *.txt</code>就会把所有的txt后缀文件加入到暂存区；也可以用<code>git add .</code>将当前文件夹下面所有的文件都添加到暂存区</strong></p></li><li><p><code>git rm --cached &lt;file&gt;</code>：把add的文件从暂存区拿出来</p></li><li><p><code>git commit -m &quot;提交信息&quot;</code>：将代码从暂存区提交到本地仓库。<span class="spoiler" tabindex="-1">小技巧：commit后面加上-a的话会直接add并提交</span></p></li><li><p><code>git log</code>：查看提交记录</p></li><li><p><code>git reflog</code>：查看所有操作历史，便于回溯</p></li><li><p><code>git ls-files</code>：查看暂存区文件</p></li><li><p><code>git reset</code>：用于回退到之前的某一个提交版本，后面可以添加三个不同参数来实现三种模式</p><ul><li><code>--soft</code>：软的，回退并保留工作区和暂存区所有修改内容</li><li><code>--hard</code>：硬的，回退并丢弃工作区和暂存区所有修改内容</li><li><code>--mixed</code>：混合的，回退但是只保留工作区的修改内容，暂存区的丢弃。这个是<strong>默认参数</strong></li><li>最后还要加上要回退的版本的id，或者<code>HEAD^</code>表示上一个版本</li></ul></li><li><p><code>git diff</code>：后面如果不加其他参数，默认比较的是工作区和暂存区之间的差异内容（显示发生更改的文件和改动的详细信息）；</p><ul><li><code>git diff HEAD</code>：比较工作区和版本库之间的差异</li><li><code>git diff --cached</code>或<code>--staged</code>：比较暂存区和版本库之间的差异</li><li><code>git diff &lt;commit_hash1&gt; &lt;commit_hash2&gt;</code>：比较任意两个版本之间的差异</li><li><code>git diff &lt;branch1&gt; &lt;branch2&gt;</code>：比较两个分支差异</li><li><code>git diff HEAD^ HEAD file.txt</code>：只查看file的差异</li></ul></li><li><p><code>git rm &lt;file&gt;</code>：把工作区和暂存区中的该文件都删除（其实等同于先删除工作区的文件，然后git add一下），然后再提交，版本库中就更新了<br><code>git rm --cached &lt;file&gt;</code>：只删除暂存区中的文件，保留工作区</p></li><li><p><code>git push &lt;remote&gt;</code>：将本地仓库内容推送到远程仓库</p></li><li><p><code>git pull &lt;remote&gt; &lt;branch&gt;</code>：将远程仓库内容拉取到本地仓库</p></li></ul><h4 id="远程仓库相关" tabindex="-1"><a class="header-anchor" href="#远程仓库相关"><span>远程仓库相关</span></a></h4><ul><li><p>添加远程仓库：<br> step1：<code>git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;</code><br> step2：<code>git push -u &lt;远程仓库名&gt; &lt;分支名&gt;</code></p></li><li><p>查看远程仓库：<code>git remote -v</code></p></li><li><p>拉取远程仓库内容：<code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>（让分支对应，如果两个分支名字相同，冒号及其后面的内容可省略）</p></li></ul><h3 id="分支" tabindex="-1"><a class="header-anchor" href="#分支"><span>分支</span></a></h3><p><em>旧版本git主分支是master，新版本改为了main，无伤大雅，据说是因为master带点种族歧视所以改名了。</em></p><ul><li><p><code>git branch &lt;分支名&gt;</code>：创建分支</p></li><li><p><code>git checkout &lt;分支名&gt;</code>（或 <code>git switch &lt;分支名&gt;</code>）：切换到分支<br> 这个checkout跟之前恢复文件命令相同，如果某个分支与某个待恢复文件重名的话，就会出现歧义，git默认会给我们切换分支，为了消除歧义，git提供了另一个命令git switch</p></li><li><p><code>git merge &lt;分支名&gt;</code>：将某个分支（命令后面的分支名）合并到当前分支，合并之后，被合并的分支不会消失</p></li><li><p><code>git log --graph --oneline --decorate --all</code>：查看分支图<br> 可以用alias给这个这么长的命令设置别名，例如：<br><code>alias graph=&quot;git log --graph --oneline --decorate --all&quot;</code></p></li><li><p><code>git branch -d &lt;分支名&gt;</code>：删除某个分支，但是如果这个分支没有被合并的话，是不能用-d删除的，要强制删除的话得用-D</p></li><li><p><code>git rebase &lt;分支名&gt;</code>：切换到某分支，然后变基到目标分支上<br> 注意，这里是将当前所处的分支，变基到指定分支名上</p></li></ul><h2 id="merge-和-rebase-对比表" tabindex="-1"><a class="header-anchor" href="#merge-和-rebase-对比表"><span>merge 和 rebase 对比表</span></a></h2><table><thead><tr><th>特性/维度</th><th><code>git merge</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td>目的</td><td>合并两个分支，保留历史</td><td>把一个分支的提交“搬到”另一个分支之上</td></tr><tr><td>历史保留方式</td><td><strong>保留原始分支结构</strong>（产生合并提交）</td><td><strong>重写提交历史</strong>（线性提交）</td></tr><tr><td>是否生成额外 commit</td><td>✅ 会产生一个新的“合并提交”</td><td>❌ 不产生额外合并提交（除非冲突需要手动）</td></tr><tr><td>历史是否干净线性</td><td>❌ 不线性，分支图会分叉</td><td>✅ 提交记录更线性，适合查看变更过程</td></tr><tr><td>是否安全（公开分支）</td><td>✅ 安全，适用于任何分支</td><td>⚠️ <strong>不建议在已 push 的共享分支使用</strong></td></tr><tr><td>使用场景</td><td>保留所有分支开发痕迹</td><td>提高可读性、简化历史，清理本地提交</td></tr><tr><td>冲突处理</td><td>合并过程中统一解决</td><td>每一次提交可能都要解决冲突</td></tr><tr><td>会不会改变 commit ID</td><td>❌ 不会</td><td>✅ 会（因为是重放提交）</td></tr><tr><td>命令示例</td><td><code>git merge feature</code></td><td><code>git rebase main</code></td></tr></tbody></table><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><ul><li><p><strong>HEAD</strong> 是 git 中一个很重要的概念，表示当前分支的最新提交<br><code>HEAD^</code>、<code>HEAD~</code> 都表示 HEAD 的前一个版本；<code>HEAD~n</code> 表示 HEAD 的前 n 个版本</p></li><li><p><strong>提交id</strong> 实际上是一串哈希码</p></li><li><p><strong>工作区 / 暂存区 / 本地仓库</strong>：见上命令转换</p></li><li><p><strong>.gitignore 文件</strong>：忽略不应该被加到版本库中的文件<br> 文件中可以用通配符（比如：<code>*.log</code> 忽略所有 <code>.log</code> 文件，<code>aa/</code> 忽略 aa 文件夹）<br> 生效前提：该文件不能已经被加入版本库<br> 可参考 GitHub 的 gitignore 模板：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">https://github.com/github/gitignore</a></p><p>应该忽略的文件示例：</p><ul><li>系统或软件自动生成的缓存</li><li>编译生成的中间文件和结果文件（如 .class、.o）</li><li>日志文件、临时缓存</li><li>包含口令、密钥等敏感信息的文件</li></ul><p><code>.gitignore</code> 匹配规则：</p><ul><li>空行或以 <code>#</code> 开头的行为注释</li><li>通配符： <ul><li><code>*</code>：匹配任意字符</li><li><code>?</code>：匹配单字符</li><li><code>[]</code>：匹配集合，如 <code>[abc]</code>、<code>[0-9]</code></li><li><code>!</code>：取反，如：<code>*.a</code> 和 <code>!lib.a</code> 表示忽略所有 <code>.a</code> 文件，除了 <code>lib.a</code></li></ul></li></ul></li></ul><h2 id="文件状态" tabindex="-1"><a class="header-anchor" href="#文件状态"><span>文件状态</span></a></h2><ul><li>未跟踪：新建文件未被 Git 管理</li><li>未修改：已被 Git 管理，未改动</li><li>已修改：已修改但未加入暂存区</li><li>已暂存：已修改并添加到暂存区，准备提交</li></ul><figure><a href="https://imgloc.com/image/9bbSb" target="_blank" rel="noopener noreferrer"><img src="https://i.imgs.ovh/2025/07/14/9bbSb.png" alt="9bbSb.png" tabindex="0" loading="lazy"></a><figcaption>9bbSb.png</figcaption></figure><h2 id="工作流模型即版本管理规范" tabindex="-1"><a class="header-anchor" href="#工作流模型即版本管理规范"><span>工作流模型即版本管理规范</span></a></h2><h3 id="gitflow模型" tabindex="-1"><a class="header-anchor" href="#gitflow模型"><span>GitFlow模型</span></a></h3><figure><a href="https://imgloc.com/image/9sNdY" target="_blank" rel="noopener noreferrer"><img src="https://i.imgs.ovh/2025/07/14/9sNdY.png" alt="9sNdY.png" tabindex="0" loading="lazy"></a><figcaption>9sNdY.png</figcaption></figure><h3 id="github-flow" tabindex="-1"><a class="header-anchor" href="#github-flow"><span>GitHub Flow</span></a></h3><figure><a href="https://imgloc.com/image/9D8Kh" target="_blank" rel="noopener noreferrer"><img src="https://i.imgs.ovh/2025/07/14/9D8Kh.png" alt="9D8Kh.png" tabindex="0" loading="lazy"></a><figcaption>9D8Kh.png</figcaption></figure><h3 id="其他规范" tabindex="-1"><a class="header-anchor" href="#其他规范"><span>其他规范</span></a></h3><figure><a href="https://imgloc.com/image/9DDot" target="_blank" rel="noopener noreferrer"><img src="https://i.imgs.ovh/2025/07/14/9DDot.png" alt="9DDot.png" tabindex="0" loading="lazy"></a><figcaption>9DDot.png</figcaption></figure>',24)]))}const g=e(l,[["render",c]]),p=JSON.parse('{"path":"/posts/BiliBiliStudy/Git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.html","title":"Git","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-11T00:00:00.000Z","category":["BiliBli网课"],"tag":["git","版本管理"],"description":"Git 可以去B站看看GeekHour的干货教程，讲得很不错 常用命令 基础 git init：将该目录初始化为仓库（会生成隐藏的git文件，随便更改会破坏所以隐藏，可以通过ls -a查看），可以在后面再加上子目录名，这样就会把子目录创建并设置为仓库 git clone <ssh/https>：克隆仓库 cd ..加 rm -rf .git（删除git...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Git\\",\\"image\\":[\\"https://i.imgs.ovh/2025/07/14/9bbSb.png\\",\\"https://i.imgs.ovh/2025/07/14/9sNdY.png\\",\\"https://i.imgs.ovh/2025/07/14/9D8Kh.png\\",\\"https://i.imgs.ovh/2025/07/14/9DDot.png\\"],\\"datePublished\\":\\"2025-07-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-16T12:11:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/BiliBiliStudy/Git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"Git"}],["meta",{"property":"og:description","content":"Git 可以去B站看看GeekHour的干货教程，讲得很不错 常用命令 基础 git init：将该目录初始化为仓库（会生成隐藏的git文件，随便更改会破坏所以隐藏，可以通过ls -a查看），可以在后面再加上子目录名，这样就会把子目录创建并设置为仓库 git clone <ssh/https>：克隆仓库 cd ..加 rm -rf .git（删除git..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://i.imgs.ovh/2025/07/14/9bbSb.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-16T12:11:10.000Z"}],["meta",{"property":"article:tag","content":"版本管理"}],["meta",{"property":"article:tag","content":"git"}],["meta",{"property":"article:published_time","content":"2025-07-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-16T12:11:10.000Z"}]]},"git":{"createdTime":1752236147000,"updatedTime":1752667870000,"contributors":[{"name":"于钊京-2207020114-Java五组-中石油学员","username":"","email":"2783238859@xiaomi.com","commits":2}]},"readingTime":{"minutes":5.82,"words":1747},"filePathRelative":"posts/BiliBiliStudy/Git版本管理.md","excerpt":"\\n<p><strong>可以去B站看看GeekHour的干货教程，讲得很不错</strong></p>\\n<h2>常用命令</h2>\\n<h3>基础</h3>\\n<ul>\\n<li>\\n<p><code>git init</code>：将该目录初始化为仓库（会生成隐藏的git文件，随便更改会破坏所以隐藏，可以通过ls -a查看），可以在后面再加上子目录名，这样就会把子目录创建并设置为仓库</p>\\n</li>\\n<li>\\n<p><code>git clone &lt;ssh/https&gt;</code>：克隆仓库</p>\\n</li>\\n<li>\\n<p><code>cd ..</code>加 <code>rm -rf .git</code>（删除git文件，让仓库变回普通目录）</p>\\n</li>\\n<li>\\n<p><code>git status</code>：查看当前仓库状态。位于哪个分支？有哪些文件以及文件状态。</p>\\n</li>\\n<li>\\n<p><code>git add</code>：将代码从工作区放入暂存区(每次更改完代码都可以先add（类似于给货车装箱，等一批货物装完了再提交到仓库），而不是直接提交到本地仓库)<br>\\n<strong>也可以使用通配符，比如：<code>git add *.txt</code>就会把所有的txt后缀文件加入到暂存区；也可以用<code>git add .</code>将当前文件夹下面所有的文件都添加到暂存区</strong></p>\\n</li>\\n<li>\\n<p><code>git rm --cached &lt;file&gt;</code>：把add的文件从暂存区拿出来</p>\\n</li>\\n<li>\\n<p><code>git commit -m \\"提交信息\\"</code>：将代码从暂存区提交到本地仓库。<span class=\\"spoiler\\" tabindex=\\"-1\\">小技巧：commit后面加上-a的话会直接add并提交</span></p>\\n</li>\\n<li>\\n<p><code>git log</code>：查看提交记录</p>\\n</li>\\n<li>\\n<p><code>git reflog</code>：查看所有操作历史，便于回溯</p>\\n</li>\\n<li>\\n<p><code>git ls-files</code>：查看暂存区文件</p>\\n</li>\\n<li>\\n<p><code>git reset</code>：用于回退到之前的某一个提交版本，后面可以添加三个不同参数来实现三种模式</p>\\n<ul>\\n<li><code>--soft</code>：软的，回退并保留工作区和暂存区所有修改内容</li>\\n<li><code>--hard</code>：硬的，回退并丢弃工作区和暂存区所有修改内容</li>\\n<li><code>--mixed</code>：混合的，回退但是只保留工作区的修改内容，暂存区的丢弃。这个是<strong>默认参数</strong></li>\\n<li>最后还要加上要回退的版本的id，或者<code>HEAD^</code>表示上一个版本</li>\\n</ul>\\n</li>\\n<li>\\n<p><code>git diff</code>：后面如果不加其他参数，默认比较的是工作区和暂存区之间的差异内容（显示发生更改的文件和改动的详细信息）；</p>\\n<ul>\\n<li><code>git diff HEAD</code>：比较工作区和版本库之间的差异</li>\\n<li><code>git diff --cached</code>或<code>--staged</code>：比较暂存区和版本库之间的差异</li>\\n<li><code>git diff &lt;commit_hash1&gt; &lt;commit_hash2&gt;</code>：比较任意两个版本之间的差异</li>\\n<li><code>git diff &lt;branch1&gt; &lt;branch2&gt;</code>：比较两个分支差异</li>\\n<li><code>git diff HEAD^ HEAD file.txt</code>：只查看file的差异</li>\\n</ul>\\n</li>\\n<li>\\n<p><code>git rm &lt;file&gt;</code>：把工作区和暂存区中的该文件都删除（其实等同于先删除工作区的文件，然后git add一下），然后再提交，版本库中就更新了<br>\\n<code>git rm --cached &lt;file&gt;</code>：只删除暂存区中的文件，保留工作区</p>\\n</li>\\n<li>\\n<p><code>git push &lt;remote&gt;</code>：将本地仓库内容推送到远程仓库</p>\\n</li>\\n<li>\\n<p><code>git pull &lt;remote&gt; &lt;branch&gt;</code>：将远程仓库内容拉取到本地仓库</p>\\n</li>\\n</ul>","autoDesc":true}');export{g as comp,p as data};
