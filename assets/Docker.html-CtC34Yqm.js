import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as o,o as i}from"./app-CDws41pK.js";const n={};function a(c,e){return i(),t("div",null,e[0]||(e[0]=[o('<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker</span></a></h1><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><p>Docker主要还是运行在Linux系统上，实现程序容器化管理。这里的镜像中没有OS内核，更加轻量。</p><ul><li>镜像，可以理解为一个安装包或者Java中的类，用来生成容器</li><li>容器，可以理解为镜像的一个运行实例<br> 镜像和容器都有各自的id<br> 除此之外，Docker的network网络也比较重要，主要有两种模式：bridge桥接模式，每个容器都有自己的ip与宿主机ip不互通，在此基础上可以建立子网。另一种为host主机模式，共用主机ip。</li></ul><h2 id="命令" tabindex="-1"><a class="header-anchor" href="#命令"><span>命令</span></a></h2><p>docker pull 镜像源（<a href="http://xn--docker-vp7i4lx15absw7ozb24h6f6b.io" target="_blank" rel="noopener noreferrer">不加默认为官方docker.io</a>）/dockerhub作者名/docker容器名称:版本号（tag）： 用于拉取镜像<br> docker run 镜像id：创建并启动容器，其实可以先不用pull，启动时如果没有从本地找到的话，会自动拉取并启动。加上 -d 会分离运行，加上 -name xxx，会将容器名字命名为xxxx，加上 -p 对外（宿主机）端口:对内（容器内）端口，可以指定端口映射。可以使用 -v 宿主机目录:容器内目录，创建挂载卷映射，也就是说这份文件在宿主机和容器里面都存在一份文件，修改随便一份，另一份会同步，删除容器，宿主机的文件不会消失<br> docker start 容器id（或者名称）：只是对容器进行启动，而不是向run命令一样总是创建容器<br> docker stop 容器id（或者名称）：停止容器<br> docker rmi 镜像id（或者名称）：删除镜像<br> docker rm 容器id（名称）：删除容器，要注意，如果容器正在运行，需要加上-f强制删除<br> docker ps：显示运行中的容器，加上-a可以查看所有容器<br> docker build -t 镜像名字:tag版本号 构建目录（.表时当前目录构建）：需要有Dockerfile文件</p>',6)]))}const l=r(n,[["render",a]]),s=JSON.parse('{"path":"/posts/BiliBiliStudy/Docker.html","title":"Docker","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-09-29T00:00:00.000Z","category":["BiliBli网课"],"tag":["Docker"],"description":"Docker 基本概念 Docker主要还是运行在Linux系统上，实现程序容器化管理。这里的镜像中没有OS内核，更加轻量。 镜像，可以理解为一个安装包或者Java中的类，用来生成容器 容器，可以理解为镜像的一个运行实例 镜像和容器都有各自的id 除此之外，Docker的network网络也比较重要，主要有两种模式：bridge桥接模式，每个容器都有自...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-09-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-11T06:27:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/BiliBiliStudy/Docker.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"Docker"}],["meta",{"property":"og:description","content":"Docker 基本概念 Docker主要还是运行在Linux系统上，实现程序容器化管理。这里的镜像中没有OS内核，更加轻量。 镜像，可以理解为一个安装包或者Java中的类，用来生成容器 容器，可以理解为镜像的一个运行实例 镜像和容器都有各自的id 除此之外，Docker的network网络也比较重要，主要有两种模式：bridge桥接模式，每个容器都有自..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-11T06:27:42.000Z"}],["meta",{"property":"article:tag","content":"Docker"}],["meta",{"property":"article:published_time","content":"2025-09-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-11T06:27:42.000Z"}]]},"git":{"createdTime":1760164062000,"updatedTime":1760164062000,"contributors":[{"name":"Jing104","username":"Jing104","email":"2046485376@qq.com","commits":1,"url":"https://github.com/Jing104"}]},"readingTime":{"minutes":1.7,"words":511},"filePathRelative":"posts/BiliBiliStudy/Docker.md","excerpt":"\\n<h2>基本概念</h2>\\n<p>Docker主要还是运行在Linux系统上，实现程序容器化管理。这里的镜像中没有OS内核，更加轻量。</p>\\n<ul>\\n<li>镜像，可以理解为一个安装包或者Java中的类，用来生成容器</li>\\n<li>容器，可以理解为镜像的一个运行实例<br>\\n镜像和容器都有各自的id<br>\\n除此之外，Docker的network网络也比较重要，主要有两种模式：bridge桥接模式，每个容器都有自己的ip与宿主机ip不互通，在此基础上可以建立子网。另一种为host主机模式，共用主机ip。</li>\\n</ul>\\n<h2>命令</h2>\\n<p>docker pull 镜像源（<a href=\\"http://xn--docker-vp7i4lx15absw7ozb24h6f6b.io\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">不加默认为官方docker.io</a>）/dockerhub作者名/docker容器名称:版本号（tag）： 用于拉取镜像<br>\\ndocker run 镜像id：创建并启动容器，其实可以先不用pull，启动时如果没有从本地找到的话，会自动拉取并启动。加上 -d 会分离运行，加上 -name xxx，会将容器名字命名为xxxx，加上 -p 对外（宿主机）端口:对内（容器内）端口，可以指定端口映射。可以使用 -v 宿主机目录:容器内目录，创建挂载卷映射，也就是说这份文件在宿主机和容器里面都存在一份文件，修改随便一份，另一份会同步，删除容器，宿主机的文件不会消失<br>\\ndocker start 容器id（或者名称）：只是对容器进行启动，而不是向run命令一样总是创建容器<br>\\ndocker stop 容器id（或者名称）：停止容器<br>\\ndocker rmi 镜像id（或者名称）：删除镜像<br>\\ndocker rm 容器id（名称）：删除容器，要注意，如果容器正在运行，需要加上-f强制删除<br>\\ndocker ps：显示运行中的容器，加上-a可以查看所有容器<br>\\ndocker build -t 镜像名字:tag版本号 构建目录（.表时当前目录构建）：需要有Dockerfile文件</p>","autoDesc":true}');export{l as comp,s as data};
