import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as t,o as r}from"./app-BIXQzZxO.js";const i={};function o(l,a){return r(),n("div",null,a[0]||(a[0]=[t('<h1 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程"><span>并发编程</span></a></h1><h2 id="jvm、jmm" tabindex="-1"><a class="header-anchor" href="#jvm、jmm"><span>JVM、JMM</span></a></h2><h3 id="串行、并发、并行" tabindex="-1"><a class="header-anchor" href="#串行、并发、并行"><span>串行、并发、并行</span></a></h3><ul><li>并发（Concurrency）指的是系统在同一时间段内处理多个任务的能力。并发关注的是任务之间的交替执行，任务之间可能并不真正同时运行，而是通过任务的分时调度机制，使得多个任务在时间上交错进行，从而给用户一种“同时”执行的感觉。并行（Parallelism）指的是系统同时执行多个任务的能力。</li><li>并行是指在多个处理器或多核处理器上，真正同时地运行多个任务。并行化的目标是提高程序的执行效率，特别是在需要处理大量数据或计算密集型任务时，并行化可以显著减少任务的完成时间。</li></ul><h3 id="jvm和jmm" tabindex="-1"><a class="header-anchor" href="#jvm和jmm"><span>JVM和JMM</span></a></h3><h4 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h4><ul><li>堆（Heap）：线程共享</li><li>方法区（Method Area）：线程共享</li><li>虚拟机栈（VM Stack）：线程私有</li><li>程序计数器（Program Counter Register）：线程私有</li><li>本地方法栈（Native Method Stack）：线程私有</li></ul><h4 id="jmm" tabindex="-1"><a class="header-anchor" href="#jmm"><span>JMM</span></a></h4><p>在多线程并发过程中，如何处理多线程读同步问题与可见性</p><ul><li>系统存在一个主内存，对于所有的线程都是共享的</li><li>每条线程都有自己的工作内存</li><li>线程对所有变量进行的操作都是先对变量进行拷贝</li></ul><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程"><span>多线程</span></a></h2><p><strong>为什么使用多线程</strong></p><ul><li>程序运行得更快！充分利用CPU资源。</li><li>目前几乎没有线上得CPU是单核的，发挥多核CPU强大的能力；<br><strong>线程生命周期</strong><br> 从创建到销毁，线程会经历各种状态以及状态之间的转换。</li><li>NEW：初始化状态</li><li>RUNNABLE：可运行/运行状态</li><li>BLOCKED：阻塞状态</li><li>WAITING：无限等待状态</li><li>TIMED_WAITING：有限等待状态</li><li>TERMINATED：终止状态</li></ul><h4 id="多线程创建方式" tabindex="-1"><a class="header-anchor" href="#多线程创建方式"><span>多线程创建方式</span></a></h4><p><strong>继承Thread类</strong> 要重写run()方法<br><strong>实现Runnable接口</strong><br><strong>实现Callable接口</strong></p><h4 id="线程状态转换" tabindex="-1"><a class="header-anchor" href="#线程状态转换"><span>线程状态转换</span></a></h4><figure><a href="https://imgse.com/i/pVVx4lq" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/21/pVVx4lq.png" alt="pVVx4lq.png" tabindex="0" loading="lazy"></a><figcaption>pVVx4lq.png</figcaption></figure><h3 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h3><p><a href="https://imgse.com/i/pVVzuB8" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/21/pVVzuB8.png" alt="pVVzuB8.png" loading="lazy"></a><br> 手动创建线程池使用ThreadPoolExecutor<br> Executors 工厂类 能够快速创建相应的线程池，但是容易出现问题，不推荐生产中使用<br> ExecutorService 线程池核心接口，定义线程池的基本功能，支持 submit、shutdown 等<br> Executor 更基础的接口，只定义了 execute(Runnable)，是 ExecutorService 的父接口</p><h4 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制"><span>运行机制</span></a></h4><figure><a href="https://imgse.com/i/pVVzlNQ" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/21/pVVzlNQ.png" alt="pVVzlNQ.png" tabindex="0" loading="lazy"></a><figcaption>pVVzlNQ.png</figcaption></figure><h2 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全"><span>线程安全</span></a></h2><p><strong>a++操作不是原子的，而是分为三部，读取a的值，值加一，写回内存</strong></p><h3 id="线程安全三要素" tabindex="-1"><a class="header-anchor" href="#线程安全三要素"><span>线程安全三要素</span></a></h3><ul><li>原子性：一个或者多个操作在CPU执行的过程不被中断的特性成为原子性 <strong>使用锁（Synchronized）</strong></li><li>有序性：程序执行的顺序按照代码的先后顺序执行（处理器可能会对指令进行重排序）</li><li>可见性：一个共享变量的更改应当被其他线程可见 <strong>Volatile</strong></li></ul><h2 id="java锁机制-lock接口" tabindex="-1"><a class="header-anchor" href="#java锁机制-lock接口"><span>Java锁机制 Lock接口</span></a></h2><ul><li>Lock接口提供了更灵活的锁定操作，相比synchronized更加灵活，功能更强 <ul><li>可重入锁 是一种递归的互斥锁，即允许单个线程对共享资源进行重复枷锁，以保证当前线程对共享资源的访问是安全的。ReentrantLock是Java中实现可重入锁的一种方式，它具有较高的灵活性和扩展性<br> ReentrantLock分为公平锁和非公平锁</li><li>读写锁：是一种共享锁</li></ul></li></ul><h2 id="并发集合" tabindex="-1"><a class="header-anchor" href="#并发集合"><span>并发集合</span></a></h2><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h3><figure><a href="https://imgse.com/i/pVZFhLR" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/21/pVZFhLR.png" alt="pVZFhLR.png" tabindex="0" loading="lazy"></a><figcaption>pVZFhLR.png</figcaption></figure><h3 id="copyonwritehashmap" tabindex="-1"><a class="header-anchor" href="#copyonwritehashmap"><span>CopyOnWriteHashmap</span></a></h3><h3 id="concurrentlinkedqueue" tabindex="-1"><a class="header-anchor" href="#concurrentlinkedqueue"><span>ConcurrentLinkedQueue</span></a></h3><h3 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue"><span>BlockingQueue</span></a></h3>',33)]))}const h=e(i,[["render",o]]),c=JSON.parse('{"path":"/posts/xiaomi/Day6%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html","title":"并发编程","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-06-21T00:00:00.000Z","category":["小米训练营"],"tag":["Java","并发"],"description":"并发编程 JVM、JMM 串行、并发、并行 并发（Concurrency）指的是系统在同一时间段内处理多个任务的能力。并发关注的是任务之间的交替执行，任务之间可能并不真正同时运行，而是通过任务的分时调度机制，使得多个任务在时间上交错进行，从而给用户一种“同时”执行的感觉。并行（Parallelism）指的是系统同时执行多个任务的能力。 并行是指在多个处...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发编程\\",\\"image\\":[\\"https://s21.ax1x.com/2025/06/21/pVVx4lq.png\\",\\"https://s21.ax1x.com/2025/06/21/pVVzuB8.png\\",\\"https://s21.ax1x.com/2025/06/21/pVVzlNQ.png\\",\\"https://s21.ax1x.com/2025/06/21/pVZFhLR.png\\"],\\"datePublished\\":\\"2025-06-21T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-24T00:35:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/xiaomi/Day6%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"并发编程"}],["meta",{"property":"og:description","content":"并发编程 JVM、JMM 串行、并发、并行 并发（Concurrency）指的是系统在同一时间段内处理多个任务的能力。并发关注的是任务之间的交替执行，任务之间可能并不真正同时运行，而是通过任务的分时调度机制，使得多个任务在时间上交错进行，从而给用户一种“同时”执行的感觉。并行（Parallelism）指的是系统同时执行多个任务的能力。 并行是指在多个处..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s21.ax1x.com/2025/06/21/pVVx4lq.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-24T00:35:32.000Z"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2025-06-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-24T00:35:32.000Z"}]]},"git":{"createdTime":1750725332000,"updatedTime":1750725332000,"contributors":[{"name":"于钊京-2207020114-Java五组-中石油学员","username":"","email":"2783238859@xiaomi.com","commits":1}]},"readingTime":{"minutes":2.96,"words":887},"filePathRelative":"posts/xiaomi/Day6并发编程.md","excerpt":"\\n<h2>JVM、JMM</h2>\\n<h3>串行、并发、并行</h3>\\n<ul>\\n<li>并发（Concurrency）指的是系统在同一时间段内处理多个任务的能力。并发关注的是任务之间的交替执行，任务之间可能并不真正同时运行，而是通过任务的分时调度机制，使得多个任务在时间上交错进行，从而给用户一种“同时”执行的感觉。并行（Parallelism）指的是系统同时执行多个任务的能力。</li>\\n<li>并行是指在多个处理器或多核处理器上，真正同时地运行多个任务。并行化的目标是提高程序的执行效率，特别是在需要处理大量数据或计算密集型任务时，并行化可以显著减少任务的完成时间。</li>\\n</ul>\\n<h3>JVM和JMM</h3>","autoDesc":true}');export{h as comp,c as data};
