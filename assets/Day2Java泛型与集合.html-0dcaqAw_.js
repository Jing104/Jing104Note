import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as n,o as r}from"./app-BxyXHe9Y.js";const p="/assets/image-1-Den_TNeH.png",s="/assets/image-2-MZzFepsL.png",i="/assets/image-3-_m72lW1E.png",o="/assets/image-4-50f4RjGs.png",h={};function l(c,a){return r(),t("div",null,a[0]||(a[0]=[n('<h1 id="day2-java泛型与集合" tabindex="-1"><a class="header-anchor" href="#day2-java泛型与集合"><span>Day2 Java泛型与集合</span></a></h1><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>Java泛型是在JavaSE 5引入的编程特性，它允许在编码时期是用类型参数来指定类型。<br> 作用：</p><ul><li>提升代码复用</li><li>增强类型安全</li></ul><h3 id="泛型引入动机" tabindex="-1"><a class="header-anchor" href="#泛型引入动机"><span>泛型引入动机</span></a></h3><ul><li>减少强制类型转换</li><li>增加类型安全</li><li>提高代码复用性和可读性</li></ul><h3 id="泛型类-泛型的一种用法" tabindex="-1"><a class="header-anchor" href="#泛型类-泛型的一种用法"><span>泛型类（泛型的一种用法）</span></a></h3><p>泛型类定义格式：修饰符 class类名&lt;代表泛型的变量&gt;{}</p><h3 id="泛型接口" tabindex="-1"><a class="header-anchor" href="#泛型接口"><span>泛型接口</span></a></h3><p>定义和泛型类差不多</p><h3 id="泛型通配符" tabindex="-1"><a class="header-anchor" href="#泛型通配符"><span>泛型通配符</span></a></h3><figure><a href="https://imgse.com/i/pVE82HU" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVE82HU.png" alt="pVE82HU.png" tabindex="0" loading="lazy"></a><figcaption>pVE82HU.png</figcaption></figure><h4 id="上界限定符" tabindex="-1"><a class="header-anchor" href="#上界限定符"><span>上界限定符</span></a></h4><figure><a href="https://imgse.com/i/pVE8WEF" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVE8WEF.png" alt="pVE8WEF.png" tabindex="0" loading="lazy"></a><figcaption>pVE8WEF.png</figcaption></figure><h4 id="下界限定符" tabindex="-1"><a class="header-anchor" href="#下界限定符"><span>下界限定符</span></a></h4><figure><a href="https://imgse.com/i/pVE8bDK" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVE8bDK.png" alt="pVE8bDK.png" tabindex="0" loading="lazy"></a><figcaption>pVE8bDK.png</figcaption></figure><h4 id="上下界限定符-pecs原则" tabindex="-1"><a class="header-anchor" href="#上下界限定符-pecs原则"><span>上下界限定符：PECS原则</span></a></h4><p>在Java泛型中，知道算则使用extends还是super限定符。</p><h3 id="泛型-编译期操作-类型擦除" tabindex="-1"><a class="header-anchor" href="#泛型-编译期操作-类型擦除"><span>泛型-编译期操作：类型擦除</span></a></h3><p>写的时候指定了各种而样的类型，但是实际上编译出来泛型类型信息会被擦除。<br><a href="https://imgse.com/i/pVEGE5Q" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEGE5Q.png" alt="pVEGE5Q.png" loading="lazy"></a>S</p><h4 id="关于泛型数组" tabindex="-1"><a class="header-anchor" href="#关于泛型数组"><span>关于泛型数组</span></a></h4><figure><a href="https://imgse.com/i/pVEG3aF" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEG3aF.png" alt="pVEG3aF.png" tabindex="0" loading="lazy"></a><figcaption>pVEG3aF.png</figcaption></figure><h4 id="高级特性-类型推断" tabindex="-1"><a class="header-anchor" href="#高级特性-类型推断"><span>高级特性-类型推断</span></a></h4><p>是指编译器根据上下文信息，自动推断出泛型类型参数的具体类型。</p><h4 id="局限性汇总" tabindex="-1"><a class="header-anchor" href="#局限性汇总"><span>局限性汇总</span></a></h4><ul><li>类型擦除：会替换为上限类型或者Object类型</li><li>不能创建泛型数组：</li><li>基本类型不能作为类型参数</li><li>静态上下文的限制</li><li>异常处理的限制：不能用catch捕获</li><li>类型参数的限制</li></ul><h2 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合"><span>Java集合</span></a></h2><h3 id="java-集合类概述" tabindex="-1"><a class="header-anchor" href="#java-集合类概述"><span>Java 集合类概述</span></a></h3><p>通常指Collection接口及其子接口和实现类<br><strong>为什么需要集合类</strong></p><ul><li>动态大小</li><li>多种数据结构</li><li>高效操作、</li><li>易于使用</li><li>标准化：提供一组标准的接口和实现，促进代码可维护性和重用性<br><strong>集合类框架图</strong><br><a href="https://imgse.com/i/pVEGDaD" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEGDaD.png" alt="pVEGDaD.png" loading="lazy"></a><br> 用得比较多的：Set、ArrayList、LinkedList、Queue在业务里用的不多，性能优化可能会用（业务里面一般用消息队列实现）</li></ul><h3 id="collection-接口" tabindex="-1"><a class="header-anchor" href="#collection-接口"><span>Collection 接口</span></a></h3><p><a href="https://imgse.com/i/pVEG6Gd" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEG6Gd.png" alt="pVEG6Gd.png" loading="lazy"></a><br> 迭代器的hasNext()方法别忘了</p><h3 id="list-接口" tabindex="-1"><a class="header-anchor" href="#list-接口"><span>List 接口</span></a></h3><p><strong>List特点</strong></p><ul><li>有序性：与添加顺序相同</li><li>可重复性</li><li>索引访问</li><li>动态大小</li></ul><h3 id="arraylist-linkedlist类" tabindex="-1"><a class="header-anchor" href="#arraylist-linkedlist类"><span>ArrayList/LinkedList类</span></a></h3><h4 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h4><p><strong>内部数据结构</strong><br> 底层用数组实现的，一段连续的内存空间。<br><strong>特点</strong></p><ul><li>随机访问快</li><li>插入和删除相对较慢</li></ul><h4 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h4><p>基于链表实现</p><h4 id="同步" tabindex="-1"><a class="header-anchor" href="#同步"><span>同步</span></a></h4><figure><img src="'+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="vector-stack-类" tabindex="-1"><a class="header-anchor" href="#vector-stack-类"><span>Vector/Stack 类</span></a></h3><p>Vector是线性安全的动态数组；stack是栈</p><h3 id="set-接口" tabindex="-1"><a class="header-anchor" href="#set-接口"><span>Set 接口</span></a></h3><p>无序性</p><h3 id="hashset-treeset-类" tabindex="-1"><a class="header-anchor" href="#hashset-treeset-类"><span>HashSet/TreeSet 类</span></a></h3><p>底层使用HashMap实现</p><h4 id="实现快速查找的原理" tabindex="-1"><a class="header-anchor" href="#实现快速查找的原理"><span>实现快速查找的原理</span></a></h4><ul><li>哈希函数</li><li>哈希桶</li><li>查找操作</li></ul><h3 id="linkedhashset-类" tabindex="-1"><a class="header-anchor" href="#linkedhashset-类"><span>LinkedHashSet 类</span></a></h3><p>底层实现：继承自HashSet<br> 性能影响：略低于HashSet<br> 应用场景：保证顺序且无重复，适合缓存等场景</p><h3 id="copyonwritearraylist类" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist类"><span>CopyOnWriteArrayList类</span></a></h3><p>成本较高但是是线程安全的，每次写的时候都会创建一个新的空间用来存储新的list。</p><h3 id="arrayblockqueue类" tabindex="-1"><a class="header-anchor" href="#arrayblockqueue类"><span>ArrayBlockQueue类</span></a></h3><figure><img src="'+s+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h3 id="delayqueue类" tabindex="-1"><a class="header-anchor" href="#delayqueue类"><span>DelayQueue类</span></a></h3><p><img src="'+i+'" alt="alt text" loading="lazy"><br><img src="'+o+'" alt="alt text" loading="lazy"><br> 不常用</p><h3 id="map-接口" tabindex="-1"><a class="header-anchor" href="#map-接口"><span>Map 接口</span></a></h3><figure><a href="https://imgse.com/i/pVENLhF" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVENLhF.png" alt="pVENLhF.png" tabindex="0" loading="lazy"></a><figcaption>pVENLhF.png</figcaption></figure><h3 id="hashmap-treemap-类" tabindex="-1"><a class="header-anchor" href="#hashmap-treemap-类"><span>HashMap/TreeMap 类</span></a></h3><figure><a href="https://imgse.com/i/pVEUSn1" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEUSn1.png" alt="pVEUSn1.png" tabindex="0" loading="lazy"></a><figcaption>pVEUSn1.png</figcaption></figure><h3 id="concurrenthashmap-类" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-类"><span>ConcurrentHashMap 类</span></a></h3><figure><a href="https://imgse.com/i/pVEUuHP" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEUuHP.png" alt="pVEUuHP.png" tabindex="0" loading="lazy"></a><figcaption>pVEUuHP.png</figcaption></figure><h3 id="iterator-迭代器" tabindex="-1"><a class="header-anchor" href="#iterator-迭代器"><span>Iterator（迭代器）</span></a></h3><h3 id="集合工具类-如-arrays、collections" tabindex="-1"><a class="header-anchor" href="#集合工具类-如-arrays、collections"><span>集合工具类（如 Arrays、Collections）</span></a></h3><h3 id="比较器-comparable-与-comparator" tabindex="-1"><a class="header-anchor" href="#比较器-comparable-与-comparator"><span>比较器（Comparable 与 Comparator）</span></a></h3><p><a href="https://imgse.com/i/pVEUogH" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEUogH.png" alt="pVEUogH.png" loading="lazy"></a><br> 要使用Collections.sort方法进行集合中元素排序的话，元素必须实现Comparable接口</p><h3 id="集合的选择与应用场景" tabindex="-1"><a class="header-anchor" href="#集合的选择与应用场景"><span>集合的选择与应用场景</span></a></h3><p><a href="https://imgse.com/i/pVEUxPS" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEUxPS.png" alt="pVEUxPS.png" loading="lazy"></a><br> 功能是第一位<br><a href="https://imgse.com/i/pVEaibq" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEaibq.png" alt="pVEaibq.png" loading="lazy"></a><br><a href="https://imgse.com/i/pVEaAaV" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEaAaV.png" alt="pVEaAaV.png" loading="lazy"></a></p><h3 id="总结与展望" tabindex="-1"><a class="header-anchor" href="#总结与展望"><span>总结与展望</span></a></h3><figure><a href="https://imgse.com/i/pVEaeGF" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/17/pVEaeGF.png" alt="pVEaeGF.png" tabindex="0" loading="lazy"></a><figcaption>pVEaeGF.png</figcaption></figure>',74)]))}const m=e(h,[["render",l]]),x=JSON.parse('{"path":"/posts/xiaomi/Day2Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88.html","title":"Day2 Java泛型与集合","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-06-17T00:00:00.000Z","category":"-小米训练营","tag":"-Java -icon - 设计模式","description":"Day2 Java泛型与集合 泛型 概念 Java泛型是在JavaSE 5引入的编程特性，它允许在编码时期是用类型参数来指定类型。 作用： 提升代码复用 增强类型安全 泛型引入动机 减少强制类型转换 增加类型安全 提高代码复用性和可读性 泛型类（泛型的一种用法） 泛型类定义格式：修饰符 class类名<代表泛型的变量>{} 泛型接口 定义和泛型类差不多...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day2 Java泛型与集合\\",\\"image\\":[\\"https://s21.ax1x.com/2025/06/17/pVE82HU.png\\",\\"https://s21.ax1x.com/2025/06/17/pVE8WEF.png\\",\\"https://s21.ax1x.com/2025/06/17/pVE8bDK.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEGE5Q.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEG3aF.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEGDaD.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEG6Gd.png\\",\\"https://s21.ax1x.com/2025/06/17/pVENLhF.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEUSn1.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEUuHP.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEUogH.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEUxPS.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEaibq.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEaAaV.png\\",\\"https://s21.ax1x.com/2025/06/17/pVEaeGF.png\\"],\\"datePublished\\":\\"2025-06-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-17T11:35:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/xiaomi/Day2Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"Day2 Java泛型与集合"}],["meta",{"property":"og:description","content":"Day2 Java泛型与集合 泛型 概念 Java泛型是在JavaSE 5引入的编程特性，它允许在编码时期是用类型参数来指定类型。 作用： 提升代码复用 增强类型安全 泛型引入动机 减少强制类型转换 增加类型安全 提高代码复用性和可读性 泛型类（泛型的一种用法） 泛型类定义格式：修饰符 class类名<代表泛型的变量>{} 泛型接口 定义和泛型类差不多..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s21.ax1x.com/2025/06/17/pVE82HU.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T11:35:31.000Z"}],["meta",{"property":"article:tag","content":"-Java -icon - 设计模式"}],["meta",{"property":"article:published_time","content":"2025-06-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-17T11:35:31.000Z"}]]},"git":{"createdTime":1750130893000,"updatedTime":1750160131000,"contributors":[{"name":"于钊京-2207020114-Java五组-中石油学员","username":"","email":"2783238859@xiaomi.com","commits":2}]},"readingTime":{"minutes":2.87,"words":861},"filePathRelative":"posts/xiaomi/Day2Java泛型与集合.md","excerpt":"\\n<h2>泛型</h2>\\n<h3>概念</h3>\\n<p>Java泛型是在JavaSE 5引入的编程特性，它允许在编码时期是用类型参数来指定类型。<br>\\n作用：</p>\\n<ul>\\n<li>提升代码复用</li>\\n<li>增强类型安全</li>\\n</ul>\\n<h3>泛型引入动机</h3>\\n<ul>\\n<li>减少强制类型转换</li>\\n<li>增加类型安全</li>\\n<li>提高代码复用性和可读性</li>\\n</ul>\\n<h3>泛型类（泛型的一种用法）</h3>\\n<p>泛型类定义格式：修饰符 class类名&lt;代表泛型的变量&gt;{}</p>\\n<h3>泛型接口</h3>\\n<p>定义和泛型类差不多</p>","autoDesc":true}');export{m as comp,x as data};
