import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as r,o as n}from"./app-CrkEJoYx.js";const p="/assets/image-5-B-N4ohJu.png",i="/assets/image-6-Cj7vcOvI.png",s="/assets/image-7-n1z0ecQd.png",o="/assets/image-8-Cizqg4RM.png",l={};function g(h,a){return n(),t("div",null,a[0]||(a[0]=[r('<h1 id="day2-javaio-设计模式" tabindex="-1"><a class="header-anchor" href="#day2-javaio-设计模式"><span>Day2 JavaIO&amp;设计模式</span></a></h1><h2 id="第1课-javai-o简介" tabindex="-1"><a class="header-anchor" href="#第1课-javai-o简介"><span>第1课 JavaI/O简介</span></a></h2><h3 id="二进制" tabindex="-1"><a class="header-anchor" href="#二进制"><span>二进制</span></a></h3><p>0/1组成，电脑能够理解<br> 二进制基本单位：</p><ul><li>位Bit（0/1）</li><li>字节Byte（八位）</li><li>字Word（多个字节组成）<br><a href="https://imgse.com/i/pVEzjTe" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEzjTe.png" alt="pVEzjTe.png" loading="lazy"></a><br><strong>核心组成</strong><br> 字节流（InputStream/OutputStream）和字符流（Reader和Writer）<br><a href="https://imgse.com/i/pVVSKlq" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVVSKlq.png" alt="pVVSKlq.png" loading="lazy"></a></li></ul><h2 id="第2课-输入流、输出流和缓冲流" tabindex="-1"><a class="header-anchor" href="#第2课-输入流、输出流和缓冲流"><span>第2课 输入流、输出流和缓冲流</span></a></h2><figure><a href="https://imgse.com/i/pVVS1mT" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVVS1mT.png" alt="pVVS1mT.png" tabindex="0" loading="lazy"></a><figcaption>pVVS1mT.png</figcaption></figure><h2 id="第4课-nio" tabindex="-1"><a class="header-anchor" href="#第4课-nio"><span>第4课 NIO</span></a></h2><h4 id="buffer详解" tabindex="-1"><a class="header-anchor" href="#buffer详解"><span>Buffer详解</span></a></h4><p><strong>概念和类型</strong></p><ul><li>概念：用于保存特定基本数据类型的容器</li><li>主要类型： <ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer<br><strong>Buffer重要属性</strong></li></ul></li><li>capacity：Buffer的容量，创建后不可改变</li><li>position：下一个要读取或写入的数据的索引</li><li>limit：第一个不应该读取或者写入的数据的索引</li><li>mark：一个备忘位置</li></ul><h4 id="channel详解" tabindex="-1"><a class="header-anchor" href="#channel详解"><span>Channel详解</span></a></h4><p><a href="https://imgse.com/i/pVEqAje" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEqAje.png" alt="pVEqAje.png" loading="lazy"></a><br><strong>FileChannel</strong><br><a href="https://imgse.com/i/pVEqZBd" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEqZBd.png" alt="pVEqZBd.png" loading="lazy"></a><br><strong>Channel间的数据传输</strong><br><img src="'+p+'" alt="alt text" loading="lazy"></p><h4 id="selector详解" tabindex="-1"><a class="header-anchor" href="#selector详解"><span>Selector详解</span></a></h4><p><img src="'+i+'" alt="alt text" loading="lazy"><br><img src="'+s+'" alt="alt text" loading="lazy"><br><a href="https://imgse.com/i/pVEqYHs" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEqYHs.png" alt="pVEqYHs.png" loading="lazy"></a><br><strong>示例讲解</strong><br><img src="'+o+'" alt="alt text" loading="lazy"></p><h2 id="第5课-设计模式概述和创建型模式" tabindex="-1"><a class="header-anchor" href="#第5课-设计模式概述和创建型模式"><span>第5课 设计模式概述和创建型模式</span></a></h2><h3 id="设计模式简介" tabindex="-1"><a class="header-anchor" href="#设计模式简介"><span>设计模式简介</span></a></h3><p><strong>什么是设计模式？</strong></p><ul><li>设计模式是软件设计中常见问题的典型解决方案</li><li>它们是经过时间检验的最佳实践</li><li>时间模式不是具体的代码，而是解决问题的一般概念<br><strong>设计模式的分类</strong><br> 、、、<br><a href="https://imgse.com/i/pVELwdA" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVELwdA.png" alt="pVELwdA.png" loading="lazy"></a></li></ul><h4 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h4><p>确保类只有一个实例</p><h4 id="工厂方法模式" tabindex="-1"><a class="header-anchor" href="#工厂方法模式"><span>工厂方法模式</span></a></h4><p>工厂方法模式的概念：<br> 定义一个用于创建对象的接口<br> 子类决定实例化哪一个类<br> （不再是我们new出来，而是工厂create出来）<br><strong>为什么用工厂模式呢？</strong><br> 数据源越来越多，那么ifelse就会越来越多；但是工厂模式能够实现动态的判断切换数据源，提高代码的可维护性。<br> 抽象工厂和普通工厂？？？？<br><a href="https://imgse.com/i/pVEOxBQ" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEOxBQ.png" alt="pVEOxBQ.png" loading="lazy"></a></p><h2 id="第6课-结构性设计模式" tabindex="-1"><a class="header-anchor" href="#第6课-结构性设计模式"><span>第6课 结构性设计模式</span></a></h2><p>结构性设计模式概述：</p><ul><li>关注类和对象的组合方式，形成更复杂的结构以创建新的结构和功能</li><li>常见的结构性设计模式： <ul><li>适配器模式</li><li>装饰器模式</li><li>···</li></ul></li></ul><h3 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式"><span>适配器模式</span></a></h3><ul><li>将一个类的接口转换成另一个接口</li><li>使得原本由于接口不兼容而不能一起工作的那些类可以一起工作<br> 适配器模式的结构：</li><li>Target：目标抽象类</li><li>Adapter：适配器类</li><li>Adaptee：适配者类</li><li>Client：客户类<br> 不一定是代码写得不对，有可能业务生态改变了，导致不适配。<br> 在其他类里面调用另一个不适配的类，然后用这个新写的来实现就算一种适配。<br><a href="https://imgse.com/i/pVEXChq" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEXChq.png" alt="pVEXChq.png" loading="lazy"></a></li></ul><h3 id="装饰器模式" tabindex="-1"><a class="header-anchor" href="#装饰器模式"><span>装饰器模式</span></a></h3><ul><li>动态地给一个对象添加一些额外的职责</li><li>就新加功能而言，相比生成子类更加灵活<br><a href="https://imgse.com/i/pVEX5vT" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEX5vT.png" alt="pVEX5vT.png" loading="lazy"></a><br> 不要因为有这些模式就害怕重构，该重构就重构</li></ul><h2 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式"><span>行为型设计模式</span></a></h2><h3 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式"><span>观察者模式</span></a></h3><p><a href="https://imgse.com/i/pVEXTrF" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEXTrF.png" alt="pVEXTrF.png" loading="lazy"></a><br><a href="https://imgse.com/i/pVEjPVH" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEjPVH.png" alt="pVEjPVH.png" loading="lazy"></a></p><h3 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式"><span>策略模式</span></a></h3><p>实际项目用得很少，写基本组件的时候可能会用到<br><a href="https://imgse.com/i/pVEjuqg" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEjuqg.png" alt="pVEjuqg.png" loading="lazy"></a><br><a href="https://imgse.com/i/pVEjULF" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/06/18/pVEjULF.png" alt="pVEjULF.png" loading="lazy"></a></p>',35)]))}const d=e(l,[["render",g]]),x=JSON.parse('{"path":"/posts/xiaomi/Day3JavaIO_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"Day2 JavaIO&设计模式","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-06-18T00:00:00.000Z","category":"-小米训练营","tag":"-Java -icon - 设计模式","description":"Day2 JavaIO&设计模式 第1课 JavaI/O简介 二进制 0/1组成，电脑能够理解 二进制基本单位： 位Bit（0/1） 字节Byte（八位） 字Word（多个字节组成） pVEzjTe.png 核心组成 字节流（InputStream/OutputStream）和字符流（Reader和Writer） pVVSKlq.png 第2课 输入流...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Day2 JavaIO&设计模式\\",\\"image\\":[\\"https://s21.ax1x.com/2025/06/18/pVEzjTe.png\\",\\"https://s21.ax1x.com/2025/06/18/pVVSKlq.png\\",\\"https://s21.ax1x.com/2025/06/18/pVVS1mT.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEqAje.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEqZBd.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEqYHs.png\\",\\"https://s21.ax1x.com/2025/06/18/pVELwdA.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEOxBQ.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEXChq.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEX5vT.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEXTrF.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEjPVH.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEjuqg.png\\",\\"https://s21.ax1x.com/2025/06/18/pVEjULF.png\\"],\\"datePublished\\":\\"2025-06-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-19T15:38:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/xiaomi/Day3JavaIO_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"Day2 JavaIO&设计模式"}],["meta",{"property":"og:description","content":"Day2 JavaIO&设计模式 第1课 JavaI/O简介 二进制 0/1组成，电脑能够理解 二进制基本单位： 位Bit（0/1） 字节Byte（八位） 字Word（多个字节组成） pVEzjTe.png 核心组成 字节流（InputStream/OutputStream）和字符流（Reader和Writer） pVVSKlq.png 第2课 输入流..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s21.ax1x.com/2025/06/18/pVEzjTe.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-19T15:38:47.000Z"}],["meta",{"property":"article:tag","content":"-Java -icon - 设计模式"}],["meta",{"property":"article:published_time","content":"2025-06-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-19T15:38:47.000Z"}]]},"git":{"createdTime":1750130893000,"updatedTime":1750347527000,"contributors":[{"name":"于钊京-2207020114-Java五组-中石油学员","username":"","email":"2783238859@xiaomi.com","commits":2}]},"readingTime":{"minutes":2.73,"words":819},"filePathRelative":"posts/xiaomi/Day3JavaIO&设计模式.md","excerpt":"\\n<h2>第1课 JavaI/O简介</h2>\\n<h3>二进制</h3>\\n<p>0/1组成，电脑能够理解<br>\\n二进制基本单位：</p>\\n<ul>\\n<li>位Bit（0/1）</li>\\n<li>字节Byte（八位）</li>\\n<li>字Word（多个字节组成）<br>\\n<a href=\\"https://imgse.com/i/pVEzjTe\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><img src=\\"https://s21.ax1x.com/2025/06/18/pVEzjTe.png\\" alt=\\"pVEzjTe.png\\" loading=\\"lazy\\"></a><br>\\n<strong>核心组成</strong><br>\\n字节流（InputStream/OutputStream）和字符流（Reader和Writer）<br>\\n<a href=\\"https://imgse.com/i/pVVSKlq\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><img src=\\"https://s21.ax1x.com/2025/06/18/pVVSKlq.png\\" alt=\\"pVVSKlq.png\\" loading=\\"lazy\\"></a></li>\\n</ul>","autoDesc":true}');export{d as comp,x as data};
