import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as t,o as n}from"./app-sAmwClK4.js";const r={};function o(s,e){return n(),i("div",null,e[0]||(e[0]=[t('<h1 id="消息队列-rabbitmq" tabindex="-1"><a class="header-anchor" href="#消息队列-rabbitmq"><span>消息队列-RabbitMQ</span></a></h1><h1 id="优势" tabindex="-1"><a class="header-anchor" href="#优势"><span>优势</span></a></h1><ul><li>耦合度低，扩展性强</li><li>异步调用，无需等待，性能好</li><li>故障隔离</li><li>缓存消息，流量削峰</li></ul><h1 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则"><span>设计原则</span></a></h1><ul><li>对于对方的执行结果不关心（执行成功也好失败也好对整个业务没有太大影响）</li><li>调用链串行变并行，提高速率</li></ul><h1 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型"><span>技术选型</span></a></h1><p>broker最常见实现方案：MQ（MessageQUeue 消息队列）<br> RabbitMQ、ActiveMQ、RocketMQ、Kafka之间的区别</p><h1 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq"><span>RabbitMQ</span></a></h1><h2 id="下载安装自己去csdn找教程吧" tabindex="-1"><a class="header-anchor" href="#下载安装自己去csdn找教程吧"><span>下载安装自己去CSDN找教程吧</span></a></h2><h2 id="管理页面" tabindex="-1"><a class="header-anchor" href="#管理页面"><span>管理页面</span></a></h2><p>默认端口：15672；默认用户名密码：guest guest</p><h3 id="整体架构和核心概念" tabindex="-1"><a class="header-anchor" href="#整体架构和核心概念"><span>整体架构和核心概念</span></a></h3><ul><li>publisher：消息发送者</li><li>consumer：消息的消费者</li><li>queue：队列，存储消息</li><li>exchange；交换机，负责路由消息<br> 生产者将消息发送给交换机，交换机按照配置将消息发给消息队列（1对1或者1对n），消费者监听特定的消息队列并消费消息<br> 交换机和消息队列就是RabbitMQ提供的中间服务，即对Broker的实现；RabbitMQ的吞吐量在十万左右，但是实际一个服务QPS可能达不到，这样我们可以多个服务共用一个RabbitMQ，这样的话要将各个服务隔离开。VirtualHost就起到一个隔离作用。<br> 模型架构图：<br><a href="https://imgloc.com/image/86u3r" target="_blank" rel="noopener noreferrer"><img src="https://i.imgs.ovh/2025/07/11/86u3r.png" alt="86u3r.png" loading="lazy"></a><br> 要在管理页面对交换机和队列做绑定<br> 可以在Admin界面管理用户、虚拟机隔离等等</li></ul><h2 id="spring-amqp-advanced-message-queue-protocol" tabindex="-1"><a class="header-anchor" href="#spring-amqp-advanced-message-queue-protocol"><span>Spring AMQP（Advanced Message Queue Protocol）</span></a></h2><p>用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。<br> Spring AMQP是对AMQP定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。<br> 默认情况下一个队列绑定了多个消费者，会轮询，一个消费者一条消息，不会考虑每个消费者的处理能力。这样不会考虑消费者是否处理完消息，可能会出现消息堆积。可以修改配置，把prefetch改为1，确保同一时刻最多投递给消费者一条消息</p><h2 id="交换机" tabindex="-1"><a class="header-anchor" href="#交换机"><span>交换机</span></a></h2><h3 id="fanout交换机-广播" tabindex="-1"><a class="header-anchor" href="#fanout交换机-广播"><span>Fanout交换机：广播</span></a></h3><p>将接收到的消息广播到每一个跟其绑定的queue</p><h3 id="direct交换机-定向" tabindex="-1"><a class="header-anchor" href="#direct交换机-定向"><span>Direct交换机：定向</span></a></h3><p>它会将接收到的消息，根据规则路由到指定的Queue，因此称为定向路由。<br> 每一个Queue都和Exchange设置一个BindingKey<br> 发布者发布消息时，指定消息的RoutingKey<br> Exchange将消息路由到BindingKey与消息RoutingKey一致的队列<br> 多个队列可以绑定相同的BindingKey，这样的话对应RoutingKey的消息会被发到这多个队列<br><em>默认就是Direct</em></p><h3 id="topic交换机" tabindex="-1"><a class="header-anchor" href="#topic交换机"><span>Topic交换机</span></a></h3><p>Topic交换机和Direct交换机类似，区别在于routingKey可以是多个单词的列表，并且以“.”分割。<br> Queue与Exchange指定BindingKey时可以使用通配符：</p><ul><li><code>#</code>：代表0个或者多个单词（其实Direct，也能绑定多个，但是都要单独绑定麻烦）</li><li><code>*</code>：代指一个单词</li></ul><h2 id="声明队列交换机" tabindex="-1"><a class="header-anchor" href="#声明队列交换机"><span>声明队列交换机</span></a></h2><p>在控制台声明交换机十分繁琐，切换开发、测试、运维等环境时还容易出错；我们应当通过java代码声明创建<br> Spring AMQP提供了几个类，用来声明队列、交换机及其绑定关系：</p><ul><li>Queue：用于声明队列，可以用工厂类QueueBuilder构建</li><li>Exchange：用于声明交换机，可以用工厂类ExchangeBuilder构建</li><li>Binding：用于声明队列和交换机的绑定关系，可以用工厂类BindingBuilder构建</li></ul><h3 id="配置类声明-configuration-bean" tabindex="-1"><a class="header-anchor" href="#配置类声明-configuration-bean"><span>配置类声明@Configuration+@Bean</span></a></h3><h3 id="基于-rabbitlistener注解来声明队列和交换机" tabindex="-1"><a class="header-anchor" href="#基于-rabbitlistener注解来声明队列和交换机"><span>基于@RabbitListener注解来声明队列和交换机</span></a></h3><h2 id="消息转换器" tabindex="-1"><a class="header-anchor" href="#消息转换器"><span>消息转换器</span></a></h2><p>java对象发送到消息队列中会被序列化成一串，所以我们要用消息转换器。<br> 引入jackson依赖，使用配置类中使用@Bean Jackson2JasonMessageConverter</p>',30)]))}const c=a(r,[["render",o]]),h=JSON.parse('{"path":"/posts/BiliBiliStudy/RabbitMQ.html","title":"消息队列-RabbitMQ","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-11T00:00:00.000Z","category":["BiliBli网课"],"tag":["黑马","消息队列","RabbitMQ"],"description":"消息队列-RabbitMQ 优势 耦合度低，扩展性强 异步调用，无需等待，性能好 故障隔离 缓存消息，流量削峰 设计原则 对于对方的执行结果不关心（执行成功也好失败也好对整个业务没有太大影响） 调用链串行变并行，提高速率 技术选型 broker最常见实现方案：MQ（MessageQUeue 消息队列） RabbitMQ、ActiveMQ、RocketM...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列-RabbitMQ\\",\\"image\\":[\\"https://i.imgs.ovh/2025/07/11/86u3r.png\\"],\\"datePublished\\":\\"2025-07-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-11T12:15:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/BiliBiliStudy/RabbitMQ.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"消息队列-RabbitMQ"}],["meta",{"property":"og:description","content":"消息队列-RabbitMQ 优势 耦合度低，扩展性强 异步调用，无需等待，性能好 故障隔离 缓存消息，流量削峰 设计原则 对于对方的执行结果不关心（执行成功也好失败也好对整个业务没有太大影响） 调用链串行变并行，提高速率 技术选型 broker最常见实现方案：MQ（MessageQUeue 消息队列） RabbitMQ、ActiveMQ、RocketM..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://i.imgs.ovh/2025/07/11/86u3r.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-11T12:15:47.000Z"}],["meta",{"property":"article:tag","content":"RabbitMQ"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:tag","content":"黑马"}],["meta",{"property":"article:published_time","content":"2025-07-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-11T12:15:47.000Z"}]]},"git":{"createdTime":1752236147000,"updatedTime":1752236147000,"contributors":[{"name":"于钊京-2207020114-Java五组-中石油学员","username":"","email":"2783238859@xiaomi.com","commits":1}]},"readingTime":{"minutes":3.37,"words":1011},"filePathRelative":"posts/BiliBiliStudy/RabbitMQ.md","excerpt":"\\n<h1>优势</h1>\\n<ul>\\n<li>耦合度低，扩展性强</li>\\n<li>异步调用，无需等待，性能好</li>\\n<li>故障隔离</li>\\n<li>缓存消息，流量削峰</li>\\n</ul>\\n<h1>设计原则</h1>\\n<ul>\\n<li>对于对方的执行结果不关心（执行成功也好失败也好对整个业务没有太大影响）</li>\\n<li>调用链串行变并行，提高速率</li>\\n</ul>\\n<h1>技术选型</h1>\\n<p>broker最常见实现方案：MQ（MessageQUeue 消息队列）<br>\\nRabbitMQ、ActiveMQ、RocketMQ、Kafka之间的区别</p>\\n<h1>RabbitMQ</h1>","autoDesc":true}');export{c as comp,h as data};
