import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,e as t,o as n}from"./app-CshBDjhq.js";const o={};function p(i,a){return n(),r("div",null,a[0]||(a[0]=[t('<h1 id="java虚拟机" tabindex="-1"><a class="header-anchor" href="#java虚拟机"><span>Java虚拟机</span></a></h1><h2 id="内存模型" tabindex="-1"><a class="header-anchor" href="#内存模型"><span>内存模型</span></a></h2><p>Java虚拟机也就是JVM，在开始这部分学习之前，我们应该联想回顾一下Java基础篇学习的jdk、jre、jvm三者之间的关系。<br> 在此，我们用一张图简洁明了的展示其三者的关系：<br><a href="https://imgse.com/i/pEHV2X6" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/04/29/pEHV2X6.png" alt="pEHV2X6.png" loading="lazy"></a><br> 补充：其中javac即编译器</p><p>除此之外，我们对内存的堆栈也进行复习：<br> 堆区和栈区本质都是内存的一块区域，只是用法不同。</p><ul><li>栈区：用于存储函数中的局部变量，用到该函数时将其局部变量放入栈区，使用完成后自动销毁，符合先入后出、后入先出的原则（栈规则），其不需要手动控制，性能较高。其空间大小一般由操作系统控制，大小是一定的，所以创建局部变量的大小不能过大否则可能导致栈溢出。</li><li>堆区：用于存储超越函数的变量，例如：<a href="https://imgse.com/i/pEHZUCd" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/04/29/pEHZUCd.png" alt="pEHZUCd.png" loading="lazy"></a>这是我们手动获取的一部分内存空间，回收也是我们手动控制，性能较低。并且所有线程共享一个堆区，要考虑线程安全的问题。堆区内存容量更大，不受物理内存限制，但是创建的变量要手动释放，否则可能内存泄露。</li></ul><h3 id="jvm的内存模型" tabindex="-1"><a class="header-anchor" href="#jvm的内存模型"><span>JVM的内存模型</span></a></h3><p>JVM （Java Virtual Machine）即Java虚拟机，可以理解为一个虚拟的小型计算机，计算机应该有的它也应该有，所以其有内存也就不难理解了。<br> JVM运行时分为虚拟机栈、堆、元空间（也叫方法区，暂时不懂有待深入学习）、程序计数器、本地方法栈（暂时不懂有待深入学习）五个部分。还有一部分内存是直接内存，属于操作系统的本地内存，也是可以直接操作的。<br> 放一张图，不懂就抓紧继续学：<br><a href="https://imgse.com/i/pEHZO2R" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/04/29/pEHZO2R.png" alt="pEHZO2R.png" loading="lazy"></a></p><p>JVM的内存结构各部分及其作用：</p><ul><li>程序计数器（The pc register）：可以看作是当前线程所执行的字节码的行号指示器，用于存储当前线程正在执行的 Java 方法的 JVM 指令地址。如果线程执行的是 Native 方法，计数器值为 null。是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域，生命周期与线程相同。（你可以把它理解为线程存档，记录该线程执行到了哪条JVM指令地址）</li><li>Java虚拟机栈Stack：JVM中的栈用来存储的是int、byte、char等基本类型数据以及对堆中对象实例的引用（指向实例地址，类似于指针），其是线程私有的（局部的）。每个线程都有自己独立的 Java 虚拟机栈，生命周期与线程相同。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出 StackOverflowError 和 OutOfMemoryError 异常。</li><li>Java堆Heap：JVM中堆用来存储对象实例（Object实例），这部分是共享的。是 JVM 中最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出 OutOfMemoryError 异常。</li><li>方法区MethodArea[永久代PermGen（1.8之前）-&gt;元空间Metaspace（1.8及以后）]： JDK 1.8 之前，使用永久代来实现方法区，其内存是堆空间的一部分，在 JDK 1.8 及以后的版本中，实现了元空间，其使用本地内存。方法区用于存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。存储的是类的元信息，联想一下Java。方法区这个概念你可以理解为一个抽象规范，而永久代和元空间是对其的实现。</li><li>本地方法（的）栈Native Method Stack：这个跟JVM的栈和方法区没有联系，只是命名类似。他是给本地方法（可以理解为其他语言编写的交给Java运行的方法，使用Native关键字修饰）提供的一个专门的栈空间。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法执行时也会创建栈帧，同样可能出现 StackOverflowError 和 OutOfMemoryError 两种错误。</li><li>运行时常量池： 是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，具有动态性，运行时也可将新的常量放入池中。当无法申请到足够内存时，会抛出 OutOfMemoryError 异常。</li><li>直接内存：不属于 JVM 运行时数据区的一部分，通过 NIO 类引入，是一种堆外内存，可以显著提高 I/O 性能。直接内存的使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。</li></ul><h3 id="jvm内存模型里的堆和栈有什么区别" tabindex="-1"><a class="header-anchor" href="#jvm内存模型里的堆和栈有什么区别"><span>JVM内存模型里的堆和栈有什么区别？</span></a></h3><p>理解前面内容之后，这个问题应该不难回答。<br><span class="spoiler" tabindex="-1">用途：栈存放的是局部变量、方法参数、方法返回值等临时数据，当一个方法被调用时，栈上就会生成一个栈帧，存储方法的相关信息，使用完毕后，自动清除栈帧。堆区存放的是对象的实例，比如new 一个对象，对象的实例就会在堆上分配空间。</span><br><span class="spoiler" tabindex="-1">生命周期：栈生命周期比较明确，当方法调用完毕后，栈帧自动销毁，其存储的临时数据自然也就被销毁。堆生命周期不明确，只有被GC（Garbage Collection）即垃圾收集器检测到不再使用才会销毁</span><br><span class="spoiler" tabindex="-1">存取速度：栈的存取速度较快，其分配和回收遵循先进后出原则，比较简单。堆存取速度较慢，分配回收需要更多时间，并且垃圾回收机制也会占用性能。</span><br><span class="spoiler" tabindex="-1">存储空间：栈的空间相对较小，且固定，由操作系统管理。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。</span><br><span class="spoiler" tabindex="-1">可见性：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。</span></p><h3 id="堆分为哪几部分呢" tabindex="-1"><a class="header-anchor" href="#堆分为哪几部分呢"><span>堆分为哪几部分呢？</span></a></h3><p><a href="https://imgse.com/i/pEHmshQ" target="_blank" rel="noopener noreferrer"><img src="https://s21.ax1x.com/2025/04/29/pEHmshQ.png" alt="pEHmshQ.png" loading="lazy"></a><br> 新生代（Young Generation）:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。<br> 老年代（Old Generation/Tenured Generation）:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。<br> 元空间（Metaspace）:从Java 8开始，永久代（Permanent Generation）被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）。元空间并不在Java堆中，而是使用本地内存，这解决了永久代容易出现的内存溢出问题。<br> 大对象区（Large Object Space / Humongous Objects）:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</p>',13)]))}const l=e(o,[["render",p]]),m=JSON.parse('{"path":"/posts/interview/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html","title":"Java虚拟机","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-04-29T00:00:00.000Z","category":["Java虚拟机"],"tag":["Java虚拟机"],"description":"Java虚拟机 内存模型 Java虚拟机也就是JVM，在开始这部分学习之前，我们应该联想回顾一下Java基础篇学习的jdk、jre、jvm三者之间的关系。 在此，我们用一张图简洁明了的展示其三者的关系： pEHV2X6.png 补充：其中javac即编译器 除此之外，我们对内存的堆栈也进行复习： 堆区和栈区本质都是内存的一块区域，只是用法不同。 栈区：...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java虚拟机\\",\\"image\\":[\\"https://s21.ax1x.com/2025/04/29/pEHV2X6.png\\",\\"https://s21.ax1x.com/2025/04/29/pEHZUCd.png\\",\\"https://s21.ax1x.com/2025/04/29/pEHZO2R.png\\",\\"https://s21.ax1x.com/2025/04/29/pEHmshQ.png\\"],\\"datePublished\\":\\"2025-04-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-29T09:50:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/interview/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"Java虚拟机"}],["meta",{"property":"og:description","content":"Java虚拟机 内存模型 Java虚拟机也就是JVM，在开始这部分学习之前，我们应该联想回顾一下Java基础篇学习的jdk、jre、jvm三者之间的关系。 在此，我们用一张图简洁明了的展示其三者的关系： pEHV2X6.png 补充：其中javac即编译器 除此之外，我们对内存的堆栈也进行复习： 堆区和栈区本质都是内存的一块区域，只是用法不同。 栈区：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s21.ax1x.com/2025/04/29/pEHV2X6.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-29T09:50:35.000Z"}],["meta",{"property":"article:tag","content":"Java虚拟机"}],["meta",{"property":"article:published_time","content":"2025-04-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-29T09:50:35.000Z"}]]},"git":{"createdTime":1745920235000,"updatedTime":1745920235000,"contributors":[{"name":"Jing104","username":"Jing104","email":"2046485376@qq.com","commits":1,"url":"https://github.com/Jing104"}]},"readingTime":{"minutes":7.38,"words":2213},"filePathRelative":"posts/interview/Java虚拟机.md","excerpt":"\\n<h2>内存模型</h2>\\n<p>Java虚拟机也就是JVM，在开始这部分学习之前，我们应该联想回顾一下Java基础篇学习的jdk、jre、jvm三者之间的关系。<br>\\n在此，我们用一张图简洁明了的展示其三者的关系：<br>\\n<a href=\\"https://imgse.com/i/pEHV2X6\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><img src=\\"https://s21.ax1x.com/2025/04/29/pEHV2X6.png\\" alt=\\"pEHV2X6.png\\" loading=\\"lazy\\"></a><br>\\n补充：其中javac即编译器</p>","autoDesc":true}');export{l as comp,m as data};
