import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as r,o}from"./app-C6KTrx7j.js";const a={};function s(i,e){return o(),n("div",null,e[0]||(e[0]=[r('<h1 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络"><span>计算机网络</span></a></h1><h2 id="网络模型" tabindex="-1"><a class="header-anchor" href="#网络模型"><span>网络模型</span></a></h2><p>OSI七层模型、TCP/IP模型、教学使用的五层模型</p><h2 id="各层协议" tabindex="-1"><a class="header-anchor" href="#各层协议"><span>各层协议</span></a></h2><p>应用层：DNS（port：53）、HTTP（80）、HTTPS（443）、SMTP、FTP（21）、SSH（22）<br> 传输层：TCP（面向连接的，可靠的）、UDP（不可靠的，尽最大可能交付的）<br> 网络层：IP<br> ...</p><h2 id="dns-domain-name-system" tabindex="-1"><a class="header-anchor" href="#dns-domain-name-system"><span>DNS（Domain Name System）</span></a></h2><p>寻找域名与Ip之间的映射<br> 浏览器缓存-本地DNS服务器-根域名服务器-顶级域名服务器-权威域名服务器<br> DNS的寻找域名和IP映射是基于UDP协议实现的，主要原因是为了更加的快速、高效、轻量，并且数据小于UDP包的大小可以实现；但是DNS的区域传输（也就是从一个主DNS服务器备份到一个次DNS服务器），这个时候传输的数据较大，并且需要严格保证顺序和可靠性，所以要用TCP。</p><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http"><span>HTTP</span></a></h2><p>HTTP1.0：短链接<br> HTTP1.1：默认长连接（connect：keep-alive），流模式代替缓存模式，允许客户端发送多个请求（服务端还是要按照顺响应）<br> HTTP2.0：头部信息和数据体信息都是二进制，允许客户端发送多个信息（服务端可以不按顺序返回），报头压缩，服务端能够直接发消息<br> HTTP3：解决TCP带来的问题，使用UDP和QUIC（保证可靠传输，将TCP和TLS的六次握手合并成三次）</p><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h2><p><strong>TCP三次握手</strong><br> 客户端发送建立请求SYN=1的报文（seq=x），由CLOSE状态进入SYN_SENT状态，此时服务端需从CLOSE状态更改为LISTEN状态接受请求报文，服务端接收到SYN报文后进入SYN_RECV状态，发送SYN=1、ACK=1的请求、确认报文（seq = y、 ack = x + 1），客户端收到该确认报文后，进入ESTABLISHED状态认为连接建立，同时因为也收到了SYN报文，所以还需要发一个ACK = 1的确认报文（seq = x + 1，ack = y + 1），服务端接收到该报文之后认为连接建立，也进入ESTABLISHED状态，至此一个TCP连接建立完成。<br> 为什么不是两次或者三次？<br> 如果是两次的话，客户端发送请求报文，服务端就会认为建立连接并发送确认报文，这个时候如果确认报文丢失，客户端发生超时重传，服务端就会建立多个连接浪费资源<br> 四次的话没有必要，可以合并成三次来节约时间<br><strong>TCP四次挥手</strong><br> 客户端发送FIN = 1 的连接关闭报文（seq = x），由ESTABLISHED状态进入FIN_WAIT1状态，服务端接收到该报文后，发送ACK = 1的确认报文（seq = y，ack = x + 1）同时进入CLOSED_WAIT状态，并开始处理未发送完的消息，客户端收到该确认报文后，进入FIN_WAIT2状态，服务端将剩余消息发送完之后，发送FIN = 1 的连接关闭报文（seq = w）并进入LAST_ACK状态等待最后客户端确认，（注意，如果服务端没有需要处理的消息，完全可以将ACK和FIN合并成一个报文实现三次挥手，此时客户端就不需要进入FIN_WAIT2状态了），客户端收到FIN报文后，发送ACK=1的确认报文（seq = x + 1，ack = w + 1），并进入TIME_WAIT状态（持续2MSL时间）（防止该确认报文丢失和旧消息传递出现问题），服务端收到该报文后进入CLOSED状态，连接关闭。<br> MSL：Maximum Segment Lifetime，是一个报文传输的最大生存时间<br><strong>SYN Flood攻击</strong><br> 一种DDos攻击，攻击者发送多个连接建立的请求报文，服务端回应后，不发送最终请求报文，导致服务端半连接队列资源被占满。<br> 防御方法：SYN Cookie半连接时生成cookie，只有收到带有该cookie的ack才建立连接和SYN防火墙使用防火墙代理，当收到ack时才建立连接。注意这两种措施都是补充，不能完全替代半连接队列<br><strong>保活计时器</strong><br> 防止客户端都挂了，服务端不知道还在傻傻的等。当超过两个小时服务端没有收到消息时，服务端向客户端发一个心跳，如果没收到客户端回应，则每隔75秒再发送一次，如果十次都没响应，说明客户端挂了，服务端可以关闭连接了。<br><strong>TCP可靠传输</strong></p><ul><li>面向连接的（三次握手）</li><li>校验和（确保发送的数据和接受的数据没有偏差）</li><li>序列号确认/应答</li><li>流量控制（滑动窗口）（发送端和接收端都有一个窗口并且会将窗口可用大小通过报文中的win进行传递）</li><li>最大消息长度</li><li>超时重传</li><li>拥塞控制（慢启动、拥塞避免、拥塞发生、快速恢复）<br><strong>拥塞控制</strong><br> 慢启动：开始时cwnd指数级增长；拥塞避免：cwnd当达到sst时，线性增长；拥塞发生：当出现丢包时，认为拥塞已经发生，这个时候有两种情况，超时重传和快速重传。如果是超时重传，则sst会变为cwnd/2，cwnd会变为1，重新慢启动过程；如果是快速重传，则cwnd = cwnd/2，sst = cwnd，进入快速恢复算法。<br><strong>Nagle算法和延迟确认</strong><br> 如果发送和确认报文携带的数据很少但是头信息很大，那么就会导致效率不高，Nagle算法和延迟重传就是解决这个问题<br> Nagle算法：当没有<em>未被确认的消息</em>，可以直接发消息；如果有<em>未被确认的消息</em>，则等到消息都被确认或者囤积的长度达到MSS时再发送<br> 延迟确认：确认方发送的ACK报文只有确认没有数据所以性能较低。当有ACK报文需要传输时，不立刻传输，而是等有数据的响应报文传输时一起传输，如果等待期间发送方发来了数据也立刻传输</li></ul><h2 id="http无状态和session、cookie" tabindex="-1"><a class="header-anchor" href="#http无状态和session、cookie"><span>HTTP无状态和Session、Cookie</span></a></h2><p>HTTP是无状态的，无法保存会话信息。<br> Cookie将信息存储在客户端，Session将信息存储在服务端<br> Cookie存储信息较短且不安全，Session存储信息长的多，且存在服务端较为安全<br> Session一般会将SessionId放在Cookie或者本地缓存（sessionStorage）中，将该信息传入后端之后，根据Session找到对应信息<br> Session有个问题，就是在分布式系统中，同一个SessionId在不同服务实例里面可能不一样或者不存在，这个时候可以使用Redis做缓存让服务端都能看到，或者直接改用JWT令牌，交由应用端解析处理<br><strong>JWT令牌</strong><br> 现在大多项目都是使用JWT令牌来存储状态信息，这样的话就不像Session那样需要额外存储信息，而是通过一个token在后端程序中动态获取用户信息。<br> 有一个问题就是JWT可能会发生泄漏，但是这个JWT你又无法收回。此时你可以立刻将该JWT失效（一般设置了失效时间），刷新JWT换用一个新的JWT，或者维护一个黑名单将这个JWT放到黑名单中，每次先校验一下是不是这个黑名单的。<br> JWT可以存在LocalStorage、SessionStorage或者Cookie中，前后端分离项目一般将JWT放在Authorization中，区别就是，Cookie是浏览器自动携带的，而Authorization是我们的前端代码通过JS手动加上的。</p><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https"><span>HTTPS</span></a></h2><p>再建立TCP三次握手之后还通过SSL/TLS三次握手建立加密通信连接。<br> SSL/TLS三次握手：首先服务端通过CA获得证书并发送给客户端，客户端验证证书（CS Hash值），获得证书中的公钥，并且生成一个Key（后续用这个key和对称加密算法传输数据），使用公钥对这个key加密，并发送给服务端，服务端通过私钥解密，获得这个key，然后通过这个key和协商好的对称加密算法将数据进行加密并进行传输。</p>',16)]))}const T=t(a,[["render",s]]),c=JSON.parse('{"path":"/posts/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html","title":"计算机网络","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-12-18T00:00:00.000Z","category":["计算机基础"],"tag":["计算机网络"],"description":"计算机网络 网络模型 OSI七层模型、TCP/IP模型、教学使用的五层模型 各层协议 应用层：DNS（port：53）、HTTP（80）、HTTPS（443）、SMTP、FTP（21）、SSH（22） 传输层：TCP（面向连接的，可靠的）、UDP（不可靠的，尽最大可能交付的） 网络层：IP ... DNS（Domain Name System） 寻找域...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计算机网络\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-18T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T09:08:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jing104\\",\\"url\\":\\"https://jing104.blog\\"}]}"],["meta",{"property":"og:url","content":"https://jing104.blog/posts/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"}],["meta",{"property":"og:site_name","content":"Jing104-Note"}],["meta",{"property":"og:title","content":"计算机网络"}],["meta",{"property":"og:description","content":"计算机网络 网络模型 OSI七层模型、TCP/IP模型、教学使用的五层模型 各层协议 应用层：DNS（port：53）、HTTP（80）、HTTPS（443）、SMTP、FTP（21）、SSH（22） 传输层：TCP（面向连接的，可靠的）、UDP（不可靠的，尽最大可能交付的） 网络层：IP ... DNS（Domain Name System） 寻找域..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T09:08:21.000Z"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:published_time","content":"2025-12-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T09:08:21.000Z"}]]},"git":{"createdTime":1767776901000,"updatedTime":1767776901000,"contributors":[{"name":"Jing104","username":"Jing104","email":"2046485376@qq.com","commits":1,"url":"https://github.com/Jing104"}]},"readingTime":{"minutes":7.05,"words":2114},"filePathRelative":"posts/interview/计算机网络.md","excerpt":"\\n<h2>网络模型</h2>\\n<p>OSI七层模型、TCP/IP模型、教学使用的五层模型</p>\\n<h2>各层协议</h2>\\n<p>应用层：DNS（port：53）、HTTP（80）、HTTPS（443）、SMTP、FTP（21）、SSH（22）<br>\\n传输层：TCP（面向连接的，可靠的）、UDP（不可靠的，尽最大可能交付的）<br>\\n网络层：IP<br>\\n...</p>\\n<h2>DNS（Domain Name System）</h2>\\n<p>寻找域名与Ip之间的映射<br>\\n浏览器缓存-本地DNS服务器-根域名服务器-顶级域名服务器-权威域名服务器<br>\\nDNS的寻找域名和IP映射是基于UDP协议实现的，主要原因是为了更加的快速、高效、轻量，并且数据小于UDP包的大小可以实现；但是DNS的区域传输（也就是从一个主DNS服务器备份到一个次DNS服务器），这个时候传输的数据较大，并且需要严格保证顺序和可靠性，所以要用TCP。</p>","autoDesc":true}');export{T as comp,c as data};
