icon: pen-to-square
date: 2026-01-14
category:
  - 算法
tag:
  - 算法
star: 10
---
# 回溯
回溯，通俗一点理解就是对一个数据进行一次变化，并对变化之后的数据进行操作记录，操作完成后将数据回溯到原本状态，再次进行下一次变化继续操作。
## 全排列
力扣题目链接：[全排列](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：
输入：nums = [1]
输出：[[1]]
分析：如果让我们人手动去算，肯定是从前往后，第一个位置可能有n（数组长度）个数字可选，第二个位置就有n-1个，以此类推，最后数量是n的阶乘，我们可以用回溯模拟这种过程。
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        //创建结果集合
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        //表示当前排列的集合
        List<Integer> cur = new ArrayList<Integer>();
        // 赋初值
        for(int num : nums){
            cur.add(num);
        }
        //直接将长度传入
        int length = nums.length;
        deal(length, cur, res, 0);
        return res;
    }
    private void deal(int length, List<Integer> cur, List<List<Integer>> res, int index){
        //如果index到了length，说明所有的位置都已经结束了，此时的cur就是一个排列结果，将其放入
        //要注意的是这里要new一个list，要不然放入多个cur引用，里面的集合是一样的
        if(index == length){
            res.add(new ArrayList<Integer>(cur));
        }
        //每个index位置都让后面的数来坐一坐，确定该index位置的数字之后，后面的继续递归调用方法确定后面的位置，每次确定之后都要回溯，保证该位置轮换时的正确性。
        for(int i = index; i < length; i++){
            Collections.swap(cur, index, i);
            deal(length, cur, res, index + 1);
            Collections.swap(cur, index, i);
        }
    }
}
```