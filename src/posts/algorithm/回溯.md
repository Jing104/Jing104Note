---
icon: pen-to-square
date: 2026-01-14
category:
  - 算法
tag:
  - 算法
star: 10
---
# 回溯
回溯，通俗一点理解就是对一个数据进行一次变化，并对变化之后的数据进行操作记录，操作完成后将数据回溯到原本状态，再次进行下一次变化继续操作。
## 全排列
力扣题目链接：[全排列](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：
输入：nums = [1]
输出：[[1]]
分析：如果让我们人手动去算，肯定是从前往后，第一个位置可能有n（数组长度）个数字可选，第二个位置就有n-1个，以此类推，最后数量是n的阶乘，我们可以用回溯模拟这种过程。
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        //创建结果集合
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        //表示当前排列的集合
        List<Integer> cur = new ArrayList<Integer>();
        // 赋初值
        for(int num : nums){
            cur.add(num);
        }
        //直接将长度传入
        int length = nums.length;
        deal(length, cur, res, 0);
        return res;
    }
    private void deal(int length, List<Integer> cur, List<List<Integer>> res, int index){
        //如果index到了length，说明所有的位置都已经结束了，此时的cur就是一个排列结果，将其放入
        //要注意的是这里要new一个list，要不然放入多个cur引用，里面的集合是一样的
        if(index == length){
            res.add(new ArrayList<Integer>(cur));
        }
        //每个index位置都让后面的数来坐一坐，确定该index位置的数字之后，后面的继续递归调用方法确定后面的位置，每次确定之后都要回溯，保证该位置轮换时的正确性。
        for(int i = index; i < length; i++){
            Collections.swap(cur, index, i);
            deal(length, cur, res, index + 1);
            Collections.swap(cur, index, i);
        }
    }
}
```

## 子集
力扣题目链接：[子集](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
```
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：
输入：nums = [0]
输出：[[],[0]]
```
这个题目解法跟回溯关系不大，不做赘述，结题方法如下：
```java
//每个元素能组成的集合是前面出现的集合与当前元素进行关联
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

        res.add(new ArrayList<>());
        int len = nums.length;
        for(int i = 0; i < len; i++){
            int size = res.size();
            for(int j = 0; j < size; j++){
                List<Integer> temp = new ArrayList<>(res.get(j));
                temp.add(nums[i]);
                res.add(temp);
            }
        }
        return res;

    }
}
```
### 电话号码的字母组合
力扣题目链接：[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
![1752723054-mfIHZs-image.png](https://pic.leetcode.cn/1752723054-mfIHZs-image.png)

```
示例 1：
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：
输入：digits = "2"
输出：["a","b","c"]
```
这个就很回溯了，跟那个全排列如出一辙，之前全排列每个index的元素都是数组中的元素，这个每个index的元素是数字所对应的字母数组中的元素。
```java
class Solution {
    //注意Map初始化的方法，Map.of()，里面的key，value等参数都用逗号分隔
    Map<Character, String> map = Map.of('2', "abc", '3', "def", '4', "ghi", '5', "jkl", '6', "mno", '7', "pqrs", '8', "tuv", '9', "wxyz");
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        int len = digits.length();
        traceBack(digits, res, len, 0, new StringBuffer());
        return res;
    }
    public void traceBack(String digits, List<String> res, int len, int index, StringBuffer cur){
        //同样，如果index跟输入长度相同说明排完了
        if(index == len){
            res.add(cur.toString());
        }else{
            char c = digits.charAt(index);
            String letters = map.get(c);
            for(int i = 0; i < letters.length(); i++){
                cur.append(letters.charAt(i));
                traceBack(digits, res, len, index + 1, cur);
                //这里注意可变字符StringBuffer的删除索引元素的方法，叫做deleteCharAt()
                cur.deleteCharAt(index);
            }
        }
    }
}
```