---
icon: pen-to-square
date: 2025-05-27
category:
  - 算法
tag:
  - 算法
---

# 矩阵
Leetcode Hot100第五个小专题，四道题，矩阵不要想得太复杂，就是一个二维数组。
## 矩阵置零
力扣题目连接：[矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)
给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

[![pVpSCHP.png](https://s21.ax1x.com/2025/05/27/pVpSCHP.png)](https://imgse.com/i/pVpSCHP)
```
示例 1：

输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```
[![pVpSFN8.png](https://s21.ax1x.com/2025/05/27/pVpSFN8.png)](https://imgse.com/i/pVpSFN8)
```
示例 2：

输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();//获取行数和列数
        vector<int> mSig(m,0); //定义行标记，当矩阵中某个元素为零时，标记其所在行
        vector<int> nSig(n,0);//定义列标记，当矩阵中某个元素为零时，标记其所在列
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(matrix[i][j]==0){
                    mSig[i]=1;
                    nSig[j]=1;
                }
            }
        }
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(mSig[i]==1||nSig[j]==1){
                    matrix[i][j] = 0;
                }
            }
        }
        
    }
};
```
## 螺旋矩阵
力扣题目连接：[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
[![pVpS6vd.png](https://s21.ax1x.com/2025/05/27/pVpS6vd.png)](https://imgse.com/i/pVpS6vd)
```
示例 1：


输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```
[![pVpSgKA.png](https://s21.ax1x.com/2025/05/27/pVpSgKA.png)](https://imgse.com/i/pVpSgKA)
```
示例 2：


输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

```cpp
//可以模拟遍历路径
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if(matrix.size()==0||matrix[0].size()==0){
            return {};
        }
        int mBegin = 0,mEnd = matrix[0].size()-1,nBegin = 0,nEnd = matrix.size()-1;//四个值分别是每一行的开始位置，每一行的结束位置，每一列的开始位置，每一列的结束位置
        while(true){
            for(int i = mBegin;i<=mEnd;i++){  //第一行从左向右遍历，加入到结果数组中
                result.push_back(matrix[nBegin][i]);
            }
            if(++nBegin>nEnd) break;//紧接着要检查一下列的起始位置，注意这里是++nBegin，也就是先自增再检查
            for(int i = nBegin;i<=nEnd;i++){//从mEnd所在列开始从上往下遍历，加入到结果中
                result.push_back(matrix[i][mEnd]);
            }
            if(--mEnd<mBegin) break;//以下同理，模拟遍历路径并作判断，可以自己根据代码走一遍示例一
            for(int i = mEnd;i>=mBegin;i--){
                result.push_back(matrix[nEnd][i]);
            }
            if(--nEnd<nBegin) break;
            for(int i=nEnd;i>=nBegin;i--){
                result.push_back(matrix[i][mBegin]);
            }
            if(++mBegin>mEnd) break;
        }
        return result;
    }
};
```