---
icon: pen-to-square
date: 2025-05-08
category:
  - 算法
tag:
  - 算法
---

# 二分法
力扣题目连接：[二分查找](https://leetcode.cn/problems/binary-search/description/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例一：
```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

```
示例二：
```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1

```

提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。
## 思路
二分查找是一个比较简单的算法，其前提条件为：
- 数组内元素是有序的
- 数组中元素不能重复，一旦重复就无法找到唯一下标了

二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 while(left < right) 还是 while(left <= right)，到底是right = middle呢，还是要right = middle - 1呢？

写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。

写二分法，区间（接下来要查找的范围）的定义一般为两种，左闭右闭即[left, right]（right也在查找范围内，结果可能是right），或者左闭右开即`[left, right)`（right不在查找范围内，最终结果不可能是right）。

### [left, right]图示以及代码
[![pELckxU.png](https://s21.ax1x.com/2025/05/08/pELckxU.png)](https://imgse.com/i/pELckxU)
因为区间为[left, right]，这里要注意：
- while(left<=right)，这里left可以等于right，因为left和right都是查找区间的一部分，所以两者相等说明只有一个查找元素了，这是有意义的。
- if(nums[middle] > target),说明target在middle左边，因为当前这个nums[middle]一定不是target，这时要将查找区间右边界right改为middle-1。if(nums[middle] < target)同理，应当将left改为middle+1.
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int size = nums.size();
        int left = 0;
        int right = size-1;
        int middle = 0;
        while(left<=right)
        {
            middle = (left + right)/2;
            if(nums[middle]>target){
                right = middle-1;
            }
            else if(nums[middle]<target){
                left = left+1;
            }
            else{
                return middle;
            }
        }
        return -1;
    }
};
```
- 时间复杂度：O(log2 n) 因为二分法每次都查找一半（即1/2）
- 空间复杂度：O(1)  空间复杂度为常数

### [left, right）图示以及代码
[![pELcJqH.png](https://s21.ax1x.com/2025/05/08/pELcJqH.png)](https://imgse.com/i/pELcJqH)
因为区间为[left, right]，这里要注意：
- while(left < right)，这里left不能等于right，因为right不是查找区间的一部分，所以当left和right相等时说明查找区间内没有数组元素内容了，这没有意义。
- if(nums[middle] > target),说明target在middle左边，因为当前这个nums[middle]一定不是target，而有边界right是取不到的，所以将查找区间右边界right改为middle就可以。但是如果if(nums[middle] < target)，应当将left改为middle+1，因为left仍是查找区间的一部分。
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int size = nums.size();
        int left = 0;
        int right = size;
        int middle = 0;
        while(left<right)
        {
            middle = (left + right)/2;
            if(nums[middle]>target){
                right = middle;
            }
            else if(nums[middle]<target){
                left = left+1;
            }
            else{
                return middle;
            }
        }
        return -1;
    }
};
```
- 时间复杂度：O(log2 n) 因为二分法每次都查找一半（即1/2）
- 空间复杂度：O(1)  空间复杂度为常数

# 搜索旋转排序数组
力扣题目连接：[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

示例 3：
输入：nums = [1], target = 0
输出：-1
## 思路
旋转数组，数组内元素是有序的，但旋转了，数组的元素顺序被打乱了。
但是旋转数组的元素是有序的，所以二分查找的思路不变，只是需要考虑旋转数组的边界条件。使用mid二分之后，一侧的数组是有序的，另一侧的数组是无序的。如果target在一侧有序数组内，则继续二分查找，否则将另一侧的数组作为新的查找区间。
## 代码
```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        // 如果数组为空，则返回-1
        if(n == 0){
            return -1;
        }
        // 如果数组只有一个元素，则判断该元素是否等于target
        if(n == 1){
            return nums[0] == target ? 0 : -1;
        }
        int l = 0 , r = n - 1;
        while (l <= r) {
            // 二分查找
            int mid = (l+r) / 2;
            if(nums[mid] == target){
                return mid;
            }
            // 判断target在哪一侧，为什么这里是<=而不是<？因为<= 可以保证 mid 恰好落在左边界时，仍然正确地认为左区间是有序的，比如数组[3,1]，如果target=1，则mid=0，此时mid恰好落在左边界，但是mid-1会越界，所以这里使用<=。
            if (nums[l] <= nums[mid]) {
                if(nums[l] <= target && target <= nums[mid]){
                    r = mid - 1;
                }
                else{
                    l = mid + 1;
                }

            }
            else{
                if(nums[mid] <= target && target <= nums[r]){
                    l = mid + 1;
                }
                else{
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}
```
