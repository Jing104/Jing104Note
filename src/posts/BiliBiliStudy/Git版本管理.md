---
icon: pen-to-square
date: 2025-07-11
category:
    - BiliBli网课
tag:
    - git
    - 版本管理
---

# Git

**可以去B站看看GeekHour的干货教程，讲得很不错**

## 常用命令

### 基础

- `git init`：将该目录初始化为仓库（会生成隐藏的git文件，随便更改会破坏所以隐藏，可以通过ls -a查看），可以在后面再加上子目录名，这样就会把子目录创建并设置为仓库

- `git clone <ssh/https>`：克隆仓库

- `cd ..`加 `rm -rf .git`（删除git文件，让仓库变回普通目录）

- `git status`：查看当前仓库状态。位于哪个分支？有哪些文件以及文件状态。

- `git add`：将代码从工作区放入暂存区(每次更改完代码都可以先add（类似于给货车装箱，等一批货物装完了再提交到仓库），而不是直接提交到本地仓库)  
  **也可以使用通配符，比如：`git add *.txt`就会把所有的txt后缀文件加入到暂存区；也可以用`git add .`将当前文件夹下面所有的文件都添加到暂存区**

- `git rm --cached <file>`：把add的文件从暂存区拿出来

- `git commit -m "提交信息"`：将代码从暂存区提交到本地仓库。!!小技巧：commit后面加上-a的话会直接add并提交!!

- `git log`：查看提交记录

- `git reflog`：查看所有操作历史，便于回溯

- `git ls-files`：查看暂存区文件

- `git reset`：用于回退到之前的某一个提交版本，后面可以添加三个不同参数来实现三种模式  
  - `--soft`：软的，回退并保留工作区和暂存区所有修改内容  
  - `--hard`：硬的，回退并丢弃工作区和暂存区所有修改内容  
  - `--mixed`：混合的，回退但是只保留工作区的修改内容，暂存区的丢弃。这个是**默认参数**  
  - 最后还要加上要回退的版本的id，或者`HEAD^`表示上一个版本

- `git diff`：后面如果不加其他参数，默认比较的是工作区和暂存区之间的差异内容（显示发生更改的文件和改动的详细信息）；  
  - `git diff HEAD`：比较工作区和版本库之间的差异  
  - `git diff --cached`或`--staged`：比较暂存区和版本库之间的差异  
  - `git diff <commit_hash1> <commit_hash2>`：比较任意两个版本之间的差异  
  - `git diff <branch1> <branch2>`：比较两个分支差异  
  - `git diff HEAD^ HEAD file.txt`：只查看file的差异

- `git rm <file>`：把工作区和暂存区中的该文件都删除（其实等同于先删除工作区的文件，然后git add一下），然后再提交，版本库中就更新了  
  `git rm --cached <file>`：只删除暂存区中的文件，保留工作区

- `git push <remote>`：将本地仓库内容推送到远程仓库

- `git pull <remote> <branch>`：将远程仓库内容拉取到本地仓库

#### 远程仓库相关

- 添加远程仓库：  
  step1：`git remote add <远程仓库别名> <远程仓库地址>`  
  step2：`git push -u <远程仓库名> <分支名>`

- 查看远程仓库：`git remote -v`

- 拉取远程仓库内容：`git pull <远程仓库名> <远程分支名>:<本地分支名>`（让分支对应，如果两个分支名字相同，冒号及其后面的内容可省略）

### 分支

*旧版本git主分支是master，新版本改为了main，无伤大雅，据说是因为master带点种族歧视所以改名了。*

- `git branch <分支名>`：创建分支

- `git checkout <分支名>`（或 `git switch <分支名>`）：切换到分支  
  这个checkout跟之前恢复文件命令相同，如果某个分支与某个待恢复文件重名的话，就会出现歧义，git默认会给我们切换分支，为了消除歧义，git提供了另一个命令git switch

- `git merge <分支名>`：将某个分支（命令后面的分支名）合并到当前分支，合并之后，被合并的分支不会消失

- `git log --graph --oneline --decorate --all`：查看分支图  
  可以用alias给这个这么长的命令设置别名，例如：  
  `alias graph="git log --graph --oneline --decorate --all"`

- `git branch -d <分支名>`：删除某个分支，但是如果这个分支没有被合并的话，是不能用-d删除的，要强制删除的话得用-D

- `git rebase <分支名>`：切换到某分支，然后变基到目标分支上  
  注意，这里是将当前所处的分支，变基到指定分支名上

## merge 和 rebase 对比表

| 特性/维度               | `git merge`                              | `git rebase`                              |
|------------------------|-------------------------------------------|--------------------------------------------|
| 目的                   | 合并两个分支，保留历史                     | 把一个分支的提交“搬到”另一个分支之上         |
| 历史保留方式           | **保留原始分支结构**（产生合并提交）       | **重写提交历史**（线性提交）                 |
| 是否生成额外 commit    |  会产生一个新的“合并提交”               |  不产生额外合并提交（除非冲突需要手动）    |
| 历史是否干净线性       |  不线性，分支图会分叉                    |  提交记录更线性，适合查看变更过程          |
| 是否安全（公开分支）   |  安全，适用于任何分支                   |  **不建议在已 push 的共享分支使用**        |
| 使用场景               | 保留所有分支开发痕迹                      | 提高可读性、简化历史，清理本地提交           |
| 冲突处理               | 合并过程中统一解决                       | 每一次提交可能都要解决冲突                  |
| 会不会改变 commit ID   |  不会                                   |  会（因为是重放提交）                      |
| 命令示例               | `git merge feature`                      | `git rebase main`                          |

## 概念

- **HEAD** 是 git 中一个很重要的概念，表示当前分支的最新提交  
  `HEAD^`、`HEAD~` 都表示 HEAD 的前一个版本；`HEAD~n` 表示 HEAD 的前 n 个版本

- **提交id** 实际上是一串哈希码

- **工作区 / 暂存区 / 本地仓库**：见上命令转换

- **.gitignore 文件**：忽略不应该被加到版本库中的文件  
  文件中可以用通配符（比如：`*.log` 忽略所有 `.log` 文件，`aa/` 忽略 aa 文件夹）  
  生效前提：该文件不能已经被加入版本库  
  可参考 GitHub 的 gitignore 模板：https://github.com/github/gitignore

  应该忽略的文件示例：

  - 系统或软件自动生成的缓存
  - 编译生成的中间文件和结果文件（如 .class、.o）
  - 日志文件、临时缓存
  - 包含口令、密钥等敏感信息的文件

  `.gitignore` 匹配规则：

  - 空行或以 `#` 开头的行为注释
  - 通配符：
    - `*`：匹配任意字符
    - `?`：匹配单字符
    - `[]`：匹配集合，如 `[abc]`、`[0-9]`
    - `!`：取反，如：`*.a` 和 `!lib.a` 表示忽略所有 `.a` 文件，除了 `lib.a`

## 文件状态

- 未跟踪：新建文件未被 Git 管理
- 未修改：已被 Git 管理，未改动
- 已修改：已修改但未加入暂存区
- 已暂存：已修改并添加到暂存区，准备提交

[![9bbSb.png](https://i.imgs.ovh/2025/07/14/9bbSb.png)](https://imgloc.com/image/9bbSb)
## 工作流模型即版本管理规范
### GitFlow模型
[![9sNdY.png](https://i.imgs.ovh/2025/07/14/9sNdY.png)](https://imgloc.com/image/9sNdY)
### GitHub Flow
[![9D8Kh.png](https://i.imgs.ovh/2025/07/14/9D8Kh.png)](https://imgloc.com/image/9D8Kh)
### 其他规范
[![9DDot.png](https://i.imgs.ovh/2025/07/14/9DDot.png)](https://imgloc.com/image/9DDot)